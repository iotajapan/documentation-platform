{"path":"docs/iot/0.1/cryptocore/iota-projects/send-value-transaction","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# Sign a bundle with the CryptoCore\n\n**In this guide, you use the CryptoCore UART API to sign a bundle.**\n\nThis guide walks you through the process of writing the following scripts:\n\n- **`create-unsigned-bundle.js`:** This script creates an unsigned bundle\n- **`generate-auth.js`:** This script generates a hexadecimal-encoded hash to authenticate the `signBundleHash` command on the CryptoCore\n- **`send_value_tx.sh`:** This scripts uses the CryptoCore to sign the bundle and attach the transactions to the Tangle\n- **`add-signature-to-bundle.js`:** This script adds the signature to the bundle\n\n:::info:\nThese code samples are also hosted on [GitHub](https://github.com/iota-community/cryptocore-scripts).\n:::\n\n:::warning:\nFor your convenience, all sample code uses the default secret key and the default API key.\n\nIf you want to use the CryptoCore in a production environment, you should follow the instructions in the 'Securing the FPGA' section of the [manual](https://gitlab.com/iccfpga-rv/iccfpga-manual/-/blob/master/iccfpga.pdf).\n:::\n\n## Prerequisites\n\nTo complete this guide, you need to have completed the [CryptoCore getting started guide](../introduction/get-started.md).\n\nYou also need Node.js installed on the Raspberry Pi. See [this article](https://github.com/nodesource/distributions/blob/master/README.md#debinstall) and follow the Ubuntu installation instructions.\n\n## Packages\n\nTo complete this guide, you need to install the following Node.js packages:\n\n--------------------\n### npm\n```bash\nnpm install @iota/core @iota/transaction-converter @iota/transaction @iota/bundle serialport cryptojs\n```\n---\n### Yarn\n```bash\nyarn add @iota/core @iota/transaction-converter @iota/transaction @iota/bundle serialport cryptojs\n```\n--------------------\n\nYou will also need to install the following Linux package:\n\n```bash\nsudo apt-get install jq\n```\n\n## Step 1. Create an unsigned bundle\n\nIn this step, you write a script that uses the Javascript client library to create an unsigned bundle.\n\n1. Create a file called `create-unsigned-bundle.js`\n\n    ```bash\n    sudo nano create-unsigned-bundle.js\n    ```\n\n2. Get the arguments that are passed to the script\n\n    ```js\n    // This argument should be a minimum weight magnitude (14 or 9)\n    const network = process.argv[2];\n\n    // This argument should be an 81 tryte address from which to withdraw IOTA tokens\n    const inputAddress = process.argv[3];\n    const inputAddressTrits = Converter.trytesToTrits(inputAddress);\n\n    // This argument should be an 81 tryte address in which to deposit the IOTA tokens from the input address\n    const outputAddressTrits = Converter.trytesToTrits(process.argv[4]);\n\n    // This argument should be a security level between 1 and 3\n    const securityLevel = parseInt(process.argv[5]);\n\n    // This argument should be the path to which you can save unfinished or pending transactions\n    const savedTransactionDirectory = process.argv[6];\n    ```\n\n2. Use the first argument to connect to a node on either the Devnet or the Mainnet\n\n    ```js\n    // Define a node for each IOTA network\n    const nodes = {\n            devnet: 'https://nodes.devnet.thetangle.org:443',\n            mainnet: `https://nodes.iota.org:443`\n    }\n\n    // Connect to the correct IOTA network, depending on the user's\n    // selection in the main script\n    if (network === 14) {\n        iota = Iota.composeAPI({\n            provider: nodes.mainnet\n            });\n    } else {\n        iota = Iota.composeAPI({\n            provider: nodes.devnet\n            });\n    }\n\n3. Define a function to create the unsigned bundle\n\n    ```js\n    async function createUnsignedBundle({ outputAddress, inputAddress, securityLevel, value }) {\n\n    let bundle = new Int8Array();\n\n    const issuanceTimestamp = Converter.valueToTrits(Math.floor(Date.now() / 1000));\n\n    // Add a transaction to the bundle to deposit the total balance of the input address to the output address\n    bundle = Bundle.addEntry(bundle, {\n    address: outputAddress,\n    value: Converter.valueToTrits(value),\n    issuanceTimestamp\n    });\n\n    // For every security level, create a new zero-value transaction to which you can later add the extra signature fragments\n    for (let i = 0; i < securityLevel; i++) {\n    bundle = Bundle.addEntry(bundle, {\n        address: inputAddress,\n        value: Converter.valueToTrits(i == 0 ? -value : 0),\n        issuanceTimestamp\n    });\n    }\n\n    // Calculate the bundle hash\n    const result = await Bundle.finalizeBundle(bundle);\n\n    // Save the bundle array to a binary file\n    // that you can later read to add the signature\n    fs.writeFileSync('bundle', result, (error) => {\n    if(!error) {\n        console.log('Bundle details saved to file');\n    } else{\n        console.log(`Error writing file: ${error}`);\n    }});\n\n    // Get the bundle hash and print it to the console\n    const bundleHash = Converter.tritsToTrytes(Transaction.bundle(result));\n    console.log(bundleHash);\n    }\n    ```\n\n4. Make sure that the input address has a non-zero balance of IOTA tokens before creating the unsigned bundle\n\n    ```js\n    // Set the default transaction value\n    let value = 0;\n\n    // Check the balance of the input address\n    iota.getBalances([inputAddress], 100)\n    .then(({ balances }) => {\n        \n        if (balances[0] === 0) {\n        console.log(\"The CryptoCore address has no IOTA tokens\");\n        console.log(\"Send IOTA tokens to the address to continue\");\n        return;\n        } else {\n        const parameters = {\n        outputAddress: outputAddressTrits,\n        inputAddress: inputAddressTrits,\n        securityLevel: securityLevel,\n        value: balances[0]\n        }\n\n        // Call the function to create an unsigned bundle and save it to a binary file\n        createUnsignedBundle(parameters);\n        }\n    })\n    .catch(error => {\n        console.log(error);\n    });\n    ```\n\n## Step 2. Authenticate the `signBundleHash` command\n\nIn this step, you write a script that generates the `auth` parameter for the [`signBundleHash`](../references/api-reference.md#signbundlehash) command.\n\n1. Install the packages\n\n    ```bash\n    cd ~/cryptocore-scripts/node-scripts\n    sudo npm i crypto-js\n    ```\n\n2. Create a file called `generate-auth.js`\n\n    ```bash\n    sudo nano generate-auth.js\n    ```\n\n3. Get the arguments that are passed to the script\n\n    ```js\n    // This argument should be a slot number between 0 and 7\n    const slot = process.argv[2];\n\n    // This argument should be a keyIndex\n    const keyIndex = process.argv[3];\n\n    // This argument should be an unsigned bundle hash\n    const bundleHash = process.argv[4];\n    ```\n\n4. Define a function to convert the integer arguments to bytes\n\n    ```js\n    // Converts an integer to bytes in the little endian format\n    function toBytesInt32 (number) {\n        return new Uint8Array([(number & 0x000000ff), (number & 0x0000ff00) >> 8, (number & 0x00ff0000) >> 16, (number & 0xff000000) >> 24]);\n    }\n    ```\n\n    :::info:\n    The CryptoJS library, which will generate the hash, requires all arguments to be converted to a Word Array from bytes.\n    :::\n    \n5. Define a function to convert bytes to a Word Array\n\n    ```js\n    // Converts bytes to a CryptoJS Word Array\n    function byteArrayToWordArray(byteArray) {\n        var wordArray = [];\n        for (i = 0; i < byteArray.length; i++) {\n                wordArray[(i / 4) | 0] |= byteArray[i] << (24 - 8 * i);\n        }\n\n        return CryptoJS.lib.WordArray.create(wordArray, byteArray.length);\n    }\n    ```\n\n6. Convert the arguments to bytes\n\n    ```js\n    let bundleHashChars = new Buffer.from(bundleHash, \"ascii\");\n    let bundleHashBytes = Uint8Array.from(bundleHashChars);\n    \n    var buffer = [];\n    \n    // Add the arguments as bytes to the buffer array\n    buffer.push(toBytesInt32(slot));\n    buffer.push(toBytesInt32(keyIndex));\n    buffer.push(bundleHashBytes);\n    buffer.push(apiKey);\n    ```\n\n7. Convert the arguments to a Word Array, then use the CryptoJS library to hash the arguments and print the hexadecimal-encoded string to the console\n\n    ```js\n    // Initialize a Keccak 384 hash object\n    const BIT_HASH_LENGTH = 384;\n    k = CryptoJS.algo.SHA3.create()\n    k.init({\n    outputLength: BIT_HASH_LENGTH,\n    })\n    \n    // Convert the bytes in the buffer array to a Word Array and add them to the hash object\n    for (let b of buffer) {\n            k.update(byteArrayToWordArray(b))\n    }\n\n    // Generate the hash\n    hash = k.finalize();\n\n    // Print the hexadecimal-encoded hash to the console\n    console.log(hash.toString(CryptoJS.enc.Hex))\n    ```\n\n    This code uses the SHA-3 method of the [CryptoJS library](https://cryptojs.gitbook.io/docs/) to hash the arguments and convert the hash to a hexadecimal-encoded string.\n\n## Step 3. Sign the bundle hash\n\nIn this step, you write a bash script that signs the bundle hash.\n\n1. Create a new file called `send_value_tx.sh`\n\n    ```bash\n    sudo nano send_value_tx.sh\n    ```\n\n2. Ask whether the user wants to create a transaction for the Devnet or the Mainnet, and store the answer in the `MWM` variable\n\n    ```bash\n    #!/bin/bash\n\n    read -p \"Are you sending this transaction to the Devnet or the Mainnet? \" MWM\n\n    if [[ $MWM =~ ^[mM] ]]\n    then\n        echo \"Setting minimum weight magnitude to 14.\"\n        MWM=14\n    else\n        echo \"Setting minimum weight magnitude to 9.\"\n        MWM=9\n    fi \n    ```\n\n3. Ask the user for the slot number of the seed that the script should use to generate an input address and sign the bundle hash\n\n    ```bash\n    read -p \"Please enter the slot number for a seed in the CryptoCore secure memory \" slot\n\n    while [[ ! $slot =~ ^[0-7]{1}$ ]]; do\n            read -p \"Please enter a valid slot number between 0 and 7\" slot\n    done\n    ```\n\n4. Set the default [security level](/docs/getting-started/0.1/clients/security-levels) to use to generate an input address\n\n    ```bash\n    securityLevel=2\n    ```\n\n    :::info:\n    Input addresses are those that are used in [input transactions](/docs/getting-started/0.1/transactions/transactions#input-transactions), which withdraw IOTA tokens from addresses.\n    :::\n\n5. Create a file to keep track of the address index that you are using to generate an input address\n\n    ```bash\n    indexFile=\"../slot-$slot-security-level-$securityLevel-unspent-address-index.js\"\n\n    # If the file does not exist, create it and set the index to 0\n    if [ ! -f $indexFile ]; then\n        echo \"Creating file to keep track of spent addresses by their key index\"\n        keyIndex=0\n        echo -e \"{\\\"index\\\":$keyIndex}\" >  $indexFile\n    else\n        # Read an existing index from the file\n        keyIndex=$(tail -n 1 $indexFile | jq .index)\n    fi\n\n    # Make sure a directory exists in which you can save unfinished or pending transactions\n    dir=\"$( dirname $( readlink -f $0 ) )\"\n    saved_transaction_directory=\"$dir/../my-transactions\"\n\n    if [ ! -d $saved_transaction_directory ]; then\n        mkdir $saved_transaction_directory\n    fi\n    ```\n\n    :::info:\n    By keeping track of the address index, you can be sure that you aren't generating [spent addresses](/docs/getting-started/0.1/clients/addresses#spent-addresses).\n    :::\n    \n\n5. Generate an input address, using the CryptoCore [`getAddress`](../references/api-reference.md#getaddress) command\n\n    ```bash\n    # Create a generateAddress API request, using the user's answer\n    template='{\"command\":\"getAddress\", \"slot\": %d, \"keyIndex\":%d, \"number\": 1, \"security\": %d}'\n\n    json_string=$(printf \"$template\" \"$slot\" \"$keyIndex\" \"$securityLevel\")\n\n    echo \"Generating an address with index $keyIndex and security level $securityLevel\"\n\n    # Open the serial terminal and enter the API request to generate the address \n    input=$(node ../node-scripts/serial.js \"$json_string\" | jq \".trytes[]\" | tr -d '\"')\n\n    echo \"If you haven't already done so, make sure that this address contains IOTA tokens: $input\"\n    ```\n\n    :::info:\n    The `serial.js` file uses the [SerialPort package](https://serialport.io/docs/guide-installation) to open a serial connection to the CryptoCore.\n\n    You can find the code for this file on [GitHub](https://github.com/iota-community/cryptocore-scripts/blob/master/node-scripts/serial.js).\n    :::\n\n6. Ask the user for an output address into which to deposit the full balance of the input address\n\n    ```bash\n    read -p \"To which address would you like to send your IOTA tokens? \" output\n\n    while [[ ! $output =~ ^[A-Z9]*{81}$ ]]; do\n        echo \"Address is invalid\"\n        read -p \"Please enter an 81 tryte address (without a checksum)\" output\n    done\n    ```\n\n7. Execute the `create-unsigned-bundle.js` script\n\n    ```bash\n    # Execute the create-unsigned-bundle.js script to create an unsigned bundle from the user's input\n    unsigned_bundle_hash=$(node ../node-scripts/create-unsigned-bundle.js $MWM $input $output $securityLevel $saved_transaction_directory)\n\n    if [[ ! $unsigned_bundle_hash =~ [A-Z9]{81} ]]; then\n        echo \"$unsigned_bundle_hash\"\n        exit 0\n    fi\n    ```\n\n8. Execute the `generate-auth.js` script to generate the `auth` argument and pass it to the [`signBundleHash`](../references/api-reference.md#signbundlehash) command to sign the bundle hash on the CryptoCore\n\n    ```bash\n\n    # Execute the generate-auth.js script to generate a valid auth parameter for the signTransaction endpoint\n    auth=$(node ../node-scripts/generate-auth.js $slot $keyIndex $unsigned_bundle_hash)\n\n    # Create an API request, using the user's answers\n    sign_bundle_template='{\"command\":\"signBundleHash\", \"slot\": %d, \"keyIndex\":%d,\"bundleHash\":\"%s\",\"security\":%d, \"auth\":\"%s\"}'\n\n    sign_bundle_json_string=$(printf \"$sign_bundle_template\" \"$slot\" \"$keyIndex\" \"$unsigned_bundle_hash\" \"$securityLevel\" \"$auth\")\n\n    echo \"Signing transaction\"\n\n    # Open the serial terminal and enter the API request to create a zero-value transaction\n    signature=$(node ../node-scripts/serial.js \"$sign_bundle_json_string\" | jq \".trytes[]\" | tr -d '\"' | tr -d '\\n')\n    ```\n\n9. Pass the signature to the `add-signature-to-bundle.js` script to add it to the bundle and attach the transactions to the Tangle\n\n    ```bash\n    result=$(node ../node-scripts/add-signature-to-bundle.js $MWM $signature $indexFile $saved_transaction_directory)\n\n    echo \"$result\"\n    ```\n\n    :::info:\n    Here, you also pass the index file that you created in step 5 to the script. This way, it can increment the index when the bundle has been attached to the Tangle.\n    :::\n\n## Step 4. Add the signature to the bundle\n\nIn this step, you write a script that adds a signature to the bundle that you saved in the `add-signature-to-bundle.js` script.\n\n1. Create a new file called `add-signature-to-bundle.js`\n\n    ```bash\n    sudo nano add-signature-to-bundle.js.\n    ```\n\n2. Use the first argument that is passed to the script to connect to a node on either the Devnet or the Mainnet\n\n    ```js\n    // This argument should be a minimum weight magnitude (14 or 9)\n    const network = parseInt(process.argv[2]);\n\n    // Define a node for each IOTA network\n    const nodes = {\n            devnet: 'https://nodes.devnet.iota.org:443',\n            mainnet: `https://nodes.iota.org:443`\n    }\n\n    // Connect to the correct IOTA network, depending on the user's\n    // selection in the main script\n    if (network === 14) {\n        iota = Iota.composeAPI({\n            provider: nodes.mainnet\n            });\n    } else {\n        iota = Iota.composeAPI({\n            provider: nodes.devnet\n            });\n    }\n    ```\n\n3. Convert the signature in the second argument to trits and store it in a variable\n\n    ```js\n    \n    // This argument should be a signature\n    const signature = process.argv[3];\n    const signatureTrits = Converter.trytesToTrits(signature)\n    ```\n\n4. Read the bundle trits from the file that was saved by the `create-unsigned-bundle.js` script\n\n    ```js\n    // This argument should be the path to which you can save unfinished or pending transactions\n    const savedTransactionDirectory = process.argv[5];\n    let bundle = new Int8Array(fs.readFileSync(`${savedTransactionDirectory}/bundle`));\n    ```\n\n5. Add the signature to the bundle, starting from the second transaction and save it to a file\n\n    ```js\n    // Transaction 0 is the output transaction, so start adding the signature fragments, starting from the second transaction in the bundle\n    bundle.set(Bundle.addSignatureOrMessage(bundle, signatureTrits, 1));\n    ```\n\n    :::info:\n    This method overwrites the bundle array with new transactions that include the signature fragments.\n    :::\n\n6. Convert each transaction in the bundle array to trytes and save them to a file\n\n    ```js\n    let trytes = []\n    for (let offset = 0; offset < bundle.length; offset += Transaction.TRANSACTION_LENGTH) {\n        trytes.push(Converter.tritsToTrytes(bundle.subarray(offset, offset + Transaction.TRANSACTION_LENGTH)));\n    }\n\n    // Reverse the trytes so that the transactions are ordered head first\n    trytes = trytes.reverse();\n\n    // Save the trytes to a file so that they can later be reattached if needed\n    fs.writeFile(`${savedTransactionDirectory}/attached_value_trytes.txt`, trytes, function(error, result)  {\n        if (error){\n            console.log(error);\n        } else {\n            console.log(\"Bundle trytes saved\");\n        }\n    });\n    ```\n\n7. Use the [`sendTrytes()`](https://github.com/iotaledger/iota.js/tree/next/packages/core#module_core.sendTrytes) method to do proof of work and send the transactions to the connected node\n\n    ```js\n    // We need the bundle to be in order head to tail before sending it to the node\n    iota.sendTrytes(trytes, depth, network)\n        .then(bundle => {\n        // Increment the index to avoid withdrawing from the same address again\n        let index = indexFile.index;\n        index++;\n        indexFile.index = index;\n        // Update the index in the file and save it\n        fs.writeFileSync(indexFilePath, JSON.stringify(indexFile));\n        console.log('Bundle sent.');\n        let tailTransactionHash = bundle[0].hash;\n        console.log(`Tail transaction hash:${tailTransactionHash}`);\n    })\n    .catch(error => {\n    console.log(error);\n    });\n    ```\n\n    :::info:\n    If the method succeeds, the index in the file is incremented so that next time you execute the script, an unspent address will be generated.\n    :::\n\n:::success:\nYou have just written a command-line interface (CLI) program that uses the CryptoCore API to sign a bundle, and attaches the transactions to the Tangle.\n:::\n\n## Run the code\n\nTo get started you need [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) installed on your device.\n\nIf you don't have a JavaScript development environment, or if this is your first time using the JavaScript client library, complete our [getting started guide](/docs/client-libraries/0.1/getting-started/js-quickstart).\n\nIn the command-line, do the following:\n\n1. Clone the repository and change into the `cryptocore-scripts/node-scripts` directory\n\n    ```bash\n    git clone https://github.com/iota-community/cryptocore-scripts\n    cd cryptocore-scripts/node-scripts\n    ```\n\n2. Install the packages\n\n    ```bash\n    sudo npm i\n    ```\n\n    You should see something like the following:\n\n    ```\n    npm notice created a lockfile as package-lock.json. You should commit this file.\n    added 128 packages from 68 contributors and audited 338 packages in 34.171s\n\n    2 packages are looking for funding\n    run `npm fund` for details\n\n    found 0 vulnerabilities\n    ```\n\n3. Run the `send_value_tx.sh` script and respond to the prompts\n\n    ```bash\n    cd ~/cryptocore-scripts/bash-scripts\n    sudo ./send_value_tx.sh\n    ```\n\n4. Follow the prompts\n\nYou should see something like the following:\n\n```\nAre you sending this transaction to the Devnet or the Mainnet? d\n\nSetting minimum weight magnitude to 9.\n\nPlease enter the slot number for a seed in the CryptoCore secure memory:0\n\nCreating file to keep track of spent addresses by their key index\n\nGenerating an address with index 0 and security level 2\n\nIf you haven't already done so, make sure that this address contains IOTA tokens: VTAEDPQVIKLHTNRFGDYCQCVXBSQHHQZTBHGORW9XMSJHFLIBNJIITBUZBGUFCTZHNPDWQXXSQLWBJLWYD\n\nTo which address would you like to send your IOTA tokens? VTAEDPQVIKLHTNRFGDYCQCVXBSQHHQZTBHGORW9XMSJHFLIBNJIITBUZBGUFCTZHNPDWQXXSQLWBJLWYD\n\nSigning transaction\nBundle sent.\nTail transaction hash:EIFWPZBERTVIEPQVGXNXCBILS9G9MLZYOHEAHTCZKXSSVLENKDVBPYATVTEZYBDRTATYKXHEZQTANQ999\n```\n\nTo see your bundle on the Tangle, copy the tail transaction hash and paste it into a [Tangle explorer](https://utils.iota.org/).\n\nIf the Tangle explorer doesn't display your transaction after 5 minutes, the node may not have sent your transaction to its neighbors.\n\nTo resend your transaction, you can pass the transaction trytes in the `my-transactions/attached_value_trytes.txt` file to the [`sendTrytes()`](https://github.com/iotaledger/iota.js/tree/next/packages/core#corestoreandbroadcasttrytes-callback) method in the JavaScript client library.\n\n## Next steps\n\nThis sample code is a simple example of how to use the CryptoCore to create a wallet that signs bundles and keeps track of spent addresses.\n\nTo improve this sample code, you could extend it to support any of the following examples:\n\n- Use the CryptoCore to do local proof of work instead of outsourcing it to the connected node through the `sendTrytes()` method\n\n    :::info:\n    For example, you could take inspiration from the `do_pow.sh` script.\n    :::\n\n- Allow the user to choose a remainder address\n\n    :::info:\n    For example, instead of transferring the whole balance of the input address to an output address, the user could transfer part of the balance and send the rest to a chosen remainder address.\n    :::\n\n- Allow the user to choose a value to send\n\n    :::info:\n    For example, you may want to ask the user how much to send, then generate a certain number of addresses to see if the user has enough balance.\n    :::\n\n- Use a configuration file to define variables that are used across all the scripts\n\n    :::info:\n    For example, you might want to define the nodes in a JSON configuration file.\n    :::\n","title":"IOTA トークンを転送する | IOTA プロジェクト | CryptoCore | IoT プロジェクト"}}
