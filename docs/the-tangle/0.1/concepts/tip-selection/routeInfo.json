{"path":"docs/the-tangle/0.1/concepts/tip-selection","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# Tip selection\n\n**Each transaction in the Tangle must reference and approve two previous transactions. Tip selection is the process whereby a node selects two random tip transactions from a subgraph of its ledger.**\n\nIn general, the tip selection algorithm selects tip transactions that have no parents.\n\nAlthough the tip selection algorithm is embedded in the [IOTA node software](/docs/iri/0.1/introduction/overview), it isn't enforced by the network. Instead, nodes are given an [incentive to use the tip selection algorithm](../concepts/incentives-in-the-tangle.md).\n\n## The tip selection process\n\nThe node selects a subgraph (also known as a subtangle) of the ledger and does two weighted random walks through it. Each weighted random walk returns a tip transaction hash.\n\n### Subgraph selection\n\nA subgraph is a section of the ledger that contains all transactions between a milestone transaction and tip transactions.\n\nThe tip selection is done on a subgraph of the ledger to save computational power. The more transactions that a node includes in the weighted random walk, the longer the tip selection process takes.\n\nFor the tip selection process, the milestone transaction for the subgraph is defined by the client, and is calculated by doing the following:\n\n`latestMilestoneIndex` - `depth`\n\nThe result of this calculation is equal to the index of the milestone transaction that is used to form the subgraph.\n\n:::info:\nThe greater the value of the `depth` parameter, the more computations the node must do. To restrict the value of the `depth` parameter, nodes can change the [`MAX-DEPTH`](/docs/iri/0.1/references/iri-configuration-options#max-depth) configuration option.\n:::\n\n### Weighted random walk\n\nA weighted random walk is an algorithm that nodes use to find a path to a tip transaction in a subgraph.\n\nTo increase the probability of selecting a path to new transactions, the algorithm favors a path through transactions that have a higher rating. This rating is called a cumulative weight.\n\nThe cumulative weight of a transaction is calculated using the following variables:\n* **Future set:** Transactions that approves the transaction\n* **[`ALPHA` configuration parameter](/docs/iri/0.1/references/iri-configuration-options#alpha):** A number that affects the randomness of the tip selection process\n\nNodes gives a high rating to a transaction with a large future set because it has a higher probability of being confirmed than one with a small future set. However, if a node were to rate transactions based only on this variable, the ledger would become a long, narrow chain of transactions, which are referenced by many other transactions. This would slow the rate of new transactions being appended to the ledger because new transactions would have to wait until they had a large enough future set before other transactions would reference them. So, to increase the speed at which new transactions are appended to the ledger, nodes also use the `ALPHA` configuration parameter to calculate the cumulative weight.\n\nThe `ALPHA` configuration parameter makes sure that the cumulative weight of each transaction is calculated with an element of randomness. This parameter allows nodes to select some transactions that have a small future set and by doing so, increase the speed at which new transactions are appended to the ledger.  \n\nFor more information about the weighted random walk, and for an in-depth explanation about the theories surrounding the best value for the `ALPHA` configuration parameter, read our [blog post](https://blog.iota.org/confirmation-rates-in-the-tangle-186ef02878bb).\n\n## In-depth explanation of the tip selection algorithm\n\nThe following information describes what nodes do when a client calls the [getTransactionsToApprove](/docs/iri/0.1/references/api-reference#getTransactionsToApprove) endpoint.\n\nClients call this endpoint when they want to send a transaction. The endpoint results in two tip transaction hashes, which are used in the `trunkTransaction` and `branchTransaction` fields of the new transaction.\n\n:::info:\nFind out more about the [structure of a transaction](/docs/iota-basics/0.1/references/structure-of-a-transaction).\n:::\n\nWhen this endpoint is called, a node starts the tip selection algorithm, which is separated into the following stages:\n\n1. Preparation\n2. Rating calculation\n3. Weighted random walk\n\n---\n\n### Preparation\n\nThe algorithm's goal is to return two non-conflicting tip transactions as a successful result of the API call.\n\nThe algorithm selects a subgraph of the ledger and does two weighted random walks through it. Each weighted random walk returns a tip transaction hash.\n\nBoth [weighted random walks](#weighted-random-walk) start from the same milestone transaction (`latestSolidMilestone - depth`).\n\nIf the client specifies a `reference` argument to the API call, the `branchTransaction` walk will start from the transaction in the `reference` argument only if that transaction is in the subgraph.\n\nIf the transaction in the `reference` argument is older than the `depth` milestone index, the API call fails with the following error message: Reference transaction is too old.\n\n## Rating calculation\n\nThe algorithm computes the rating of every transaction in the subgraph. These ratings will be subsequently transformed into weights during the weighted random walk to bias the walker's path.\n\nThe rating calculation is performed only once, and used to select both tip transactions.\n\n#### Interface\n\nTo allow you to create different rating algorithms, we created a generic interface to which every rating calculator should adhere.\n\n```java\nMap<TxId -> Integer> calculate(TxId entryPoint)\n```\n\nEvery rating calculator, being invoked with an `entryPoint` transaction, should return a mapping of transaction IDs with their corresponding rating value expressed as integers.\n\n#### Future set creation\n\nFor every transaction included in our sorted subgraph, a future set is created, containing direct and indirect approvers. The rating of each transaction is the size of its future set + 1 (the transaction's own weight).\n\n```java\nentryPoint = latestSolidMilestone - depth\n\nentryPointTrunk = entryPoint\n\nentryPointBranch = reference or entry point \n\nratings = CumulativeWeightCalculator.calculate(entryPointTrunk)\n\nclass CumulativeWeightCalculator(RatingCalculator):\n\n    def calculate(startTx):\n\n        rating = dict()\n\n        subgraph = Tangle(startTx)\n\n        topologicalSubgraph = sortTopologically(subgraph)\n\n        for tx in topologicalSubgraph:\n\n            rating[tx] = len(futureSet(tx)) + 1\n\n        return rating\n\n```\n\n#### Optimizations\n\n* In order to preserve space while storing transaction's identifiers, we only store a portion of the transaction's hash bytes, truncating it to the `PREFIX_LENGTH` length. Currently, this value has been hardcoded to 44 bytes, corresponding to 220 trits.\n\n* In order to cap the memory consumption of the algorithm, we allow to store up to `MAX_FUTURE_SET_SIZE` number of approvers for the transaction we are considering, under the assumption that a higher rating score won't contribute significantly to bias the walker. This value has been heuristically hardcoded to 5000. Please note that this optimization, while capping memory usage during runtime, makes the walk to behave more randomly closer the beginning of the considered subgraph since the future sets of those transactions are more likely to have been capped to `MAX_FUTURE_SET_SIZE`. The desired behavior is instead the contrary: we would like the beginning of the walk to be strongly biased towards the main branch while being more random closer to the tips, spreading the chance for any of them to get selected. \n\n### Weighted random walk\n\nAfter the transactions' ratings have been computed, the weighted random walk starts. \n\n#### Interface\n\nTo allow you to create different weighted random walk algorithms, we created a generic interface to which every implementation should adhere.\n\n```java\nTxId walk(TxId entryPoint, Map<TxId -> Integer> ratings, WalkValidator validator)\n```\n\nThis function should return the selected tip transaction.\n\n#### WalkerAlpha Implementation\n\nRatings are normalized and transformed into `weights` with the help of the `alpha` configuration option. Finally, a `random` value between 0 and the sum of all the weights is generated and subtracted by the approvers' weights until reaching the value of 0. The approver that turned the `random` value to 0 is selected as the next step in the walk.\n\n```python\nclass WalkerAlpha(Walker):\n\n    def walk(entryPoint, ratings, validator):\n\n        step = entryPoint\n\n        prevStep = None\n\n        while step:\n\n            approvers = getApprovers(step)\n\n            prevStep = step\n\n            step = nextStep(ratings, approvers, validator)\n\n        # When there are no more steps, this transaction is a tip\n\n        return prevStep\n\n        \n\n    def nextStep(ratings, approvers, validator):\n\n        approversWithRating = approvers.filter(a => ratings.contains(a))\n\n        # There is no valid approver, this transaction is a tip\n\n        if len(approversWithRating) == 0:\n\n            return None\n\n        approversRatings = approverswithRating.map(a => ratings.get(a))\n\n        weights = ratingsToWeights(approversRatings)\n\n        approver = weightedChoice(approversWithRating, weights)\n\n        if approver is not None:\n\n            tail = validator.findTail(approver)\n\n            # If the selected approver is invalid, step back and try again\n\n            if validator.isInvalid(tail):\n\n                approvers = approvers.remove(approver)\n\n                return nextStep(ratings, approvers, validator)\n\n            return tail\n\n        return None\n\n    \n\n    def weightedChoice(approvers, weights):\n\n        randomNumber = random(0, sum(weights))\n\n        for approver in approvers:\n\n            randomNumber = randomNumber - weights.get(approver)\n\n            if randomNumber <= 0:\n\n                return approver\n\n    def ratingsToWeights(ratings):\n\n        highestRating = max(ratings)\n\n        normalizedRatings = ratings.map(r => r - highestRating)\n\n        weights = normalizedRatings.map(r => math.exp(r * alpha))\n\n        return weights\n\n```\n\n#### Validator conditions\n\nA transaction is considered invalid if any of the following occur:\n\n* It is not solid and we cannot reconstruct its state, since a portion of the Tangle that this transaction references is unknown.\n\n* It references a transaction that's too far in the past, namely beyond `latestSolidMilestone - maxDepth`.\n\n* The ledger state is not consistent, such as trying to withdraw or deposit missing funds or double-spending.\n\n* The validator maintains a list of transactions that have been checked for validity. Every time a new transaction is validated, it is also checked against these.\n\n```python\nclass WalkValidator:\n\n    previousTransactions = []\n\n    def isInvalid(transaction):\n\n        previousTransactions.append(transaction)\n\n        if notSolid(transaction):\n\n            return True\n\n        if belowMaxDepth(transaction):\n\n            return True \n\n        if inconsistent(transaction):\n\n            return True\n\n        if inconsistentWithPreviousTransactions(transaction):\n\n            return True\n\n        return False\n\n```\n\n:::info:\nThe same validator object is passed for both walks, resulting in two tip transactions that are consistent with each other.\n:::\n\n#### Bundles and consistency\n\nTransactions in IOTA are sent in bundles. Therefore, when the walker traverses an approver, that approver may be in the middle of a bundle. To validate the bundle, the walker finds the tail transaction by traversing the trunk transactions. \n\nThe two tip transactions are checked for consistency between each other to make sure that neither one is invalid. Therefore, the clients transaction references two valid transactions that have a better chance of being approved by another transaction, thus increasing its cumulative weight.\n","title":"Tip selection | Concepts | タングル"}}
