{"path":"docs/wallets/0.1/hub/how-to-guides/recover-tokens","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# 使用済みアドレスから IOTA トークンをリカバーする\n<!-- # Recover IOTA tokens from a spent address -->\n\n**ユーザーが[スウィープ](../concepts/sweeps.md)に既に含まれている[使用済みアドレス](/docs/getting-started/0.1/clients/addresses#spent-addresses)に IOTA トークンをデポジットする場合があります．この場合，攻撃者が署名をブルートフォースして IOTA トークンを盗もうとするリスクがあります．使用済みアドレスから IOTA トークンをリカバーするために，潜在的な攻撃者ができる前に IOTA トークンを新しいアドレスに転送しようとすることができます．これにより，アドレスの秘密鍵がより多く公開されますが，IOTA トークンを安全なアドレスに転送するためには避けられません．**\n<!-- **Sometimes users deposit IOTA tokens into [spent addresses](/docs/getting-started/0.1/clients/addresses#spent-addresses) that have already been included in a [sweep](../concepts/sweeps.md). In this case, the address is at risk of an attacker trying to brute force its signature to steal its tokens. To recover the tokens from the spent address, you can try to transfer them to a new address before a potential attacker can. Doing so exposes more of the address's private key, but this is inevitable to transfer the IOTA tokens to a safe address.** -->\n\nこのガイドでは，`signBundle()` gRPC メソッドを使用して，使用済みアドレスから IOTA トークンをリカバーします．この方法は，使用済みアドレスの合計残高を1つ以上の出力アドレスにデポジットするカスタムバンドルを作成するのに役立ちます．\n<!-- In this guide, we use the `signBundle()` gRPC method to recover IOTA tokens from a spent address. This method is useful for creating a custom bundle that deposits any amount of the spent address's total balance into one or more output addresses. -->\n\n:::info:\n使用済みアドレスの合計残高を単一の出力アドレスに転送するには，`recoverFunds()` メソッドを使用する方が簡単です．\n:::\n<!-- :::info: -->\n<!-- To transfer the total balance of a spent address into a single output address, it's easier to use the `recoverFunds()` API call. -->\n<!-- ::: -->\n\n## 前提条件\n<!-- ## Prerequisites -->\n\nこのガイドを完了するには，次のものが必要です．\n<!-- To complete this guide, you need the following: -->\n\n- [ハブのインスタンス](../how-to-guides/install-hub.md)\n<!-- - An [instance of Hub](../how-to-guides/install-hub.md) -->\n- [Node.js の開発者環境](/docs/client-libraries/0.1/getting-started/js-quickstart)\n<!-- - [A Node.js developer environment](/docs/client-libraries/0.1/getting-started/js-quickstart) -->\n- [`@iota/bundle`](https://github.com/iotaledger/iota.js/tree/next/packages/bundle)，[`@iota/core`](https://github.com/iotaledger/iota.js/tree/next/packages/core)，[`@iota/converter`](https://github.com/iotaledger/iota.js/tree/next/packages/converter)，および[`@iota/transaction`](https://github.com/iotaledger/iota.js/tree/next/packages/transaction) パッケージ\n<!-- - The [`@iota/bundle`](https://github.com/iotaledger/iota.js/tree/next/packages/bundle), [`@iota/core`](https://github.com/iotaledger/iota.js/tree/next/packages/core), [`@iota/converter`](https://github.com/iotaledger/iota.js/tree/next/packages/converter), and [`@iota/transaction`](https://github.com/iotaledger/iota.js/tree/next/packages/transaction) packages -->\n- [`SignBundle_enabled` flag](../references/command-line-options.md#signBundle) を `true` に設定します．\n<!-- - The [`SignBundle_enabled` flag](../references/command-line-options.md#signBundle) set to `true`. -->\n\n## 手順1. 未署名のバンドルを作成する\n<!-- ## Step 1. Create an unsigned bundle -->\n\nハブがバンドルに署名する前に，未署名のバンドルを作成する必要があります．\n<!-- Before Hub can sign a bundle, you need to create an unsigned one. -->\n\n:::info:\nこのガイドでは，JavaScript クライアントライブラリを使用してバンドルを作成および送信しますが，Go，Java，Python などの他の[公式およびコミュニティライブラリ](/docs/client-libraries/0.1/introduction/overview)もあります．\n:::\n<!-- :::info: -->\n<!-- <!-- In this guide, we use the JavaScript client library to create and send the bundle, but we also have other [official and community libraries](/docs/client-libraries/0.1/introduction/overview), including Go, Java, and Python. --> -->\n<!-- ::: -->\n\n1. 署名されていないバンドルを作成してファイルに保存する関数を作成します．\n  <!-- 1. Write a function that creates an unsigned bundle and saves it to a file -->\n\n    ```js\n    async function createUnsignedBundle({ outputAddress, inputAddress, securityLevel, value }) {\n    let bundle = new Int8Array();\n    const issuanceTimestamp = Converter.valueToTrits(Math.floor(Date.now() / 1000));\n\n    bundle = Bundle.addEntry(bundle, {\n      address: outputAddress,\n      value: Converter.valueToTrits(value),\n      issuanceTimestamp\n    });\n\n    // セキュリティレベルごとに，新しいゼロトークントランザクションを作成します．このトランザクションに後で残りの署名フラグメントを追加できます．\n    for (let i = 0; i < securityLevel; i++) {\n      bundle = Bundle.addEntry(bundle, {\n        address: inputAddress,\n        value: Converter.valueToTrits(i == 0 ? -value : 0),\n        issuanceTimestamp\n      });\n    }\n\n    const result = await Bundle.finalizeBundle(bundle);\n\n    // バンドル配列をバイナリファイルに保存します．\n    fs.writeFileSync('bundle', result, (error) => {\n      if(!error) {\n        console.log('Bundle details saved to file');\n      } else{\n        console.log(`Error writing file: ${error}`);\n      }});\n\n    const bundleHash = Converter.tritsToTrytes(Transaction.bundle(result));\n\n    console.log(bundleHash);\n    }\n    ```\n\n2. ハブから次の値を取得し，それらを `parameters` オブジェクトに追加します．\n  <!-- 2. Get the following values from Hub and add them to the `parameters` object: -->\n\n    | **フィールド** | **説明** | **メモ** |\n    | :------------- | :------- | :------- |\n    | `outputAddress` | 使用済みアドレスから IOTA トークンを転送する新しい81トライトのアドレス（チェックサムなし） | このアドレスは，ハブアドレスである必要はありません．たとえば，IOTA トークンをハードウェアウォレットのアドレスに送信できます． |\n    | `inputAddress` | リカバーする必要がある IOTA トークンを含む，81トライトの使用済みアドレス（チェックサムなし） | [`balanceSubscription()` メソッド](../references/grpc-api-reference.md#hub.rpc.BalanceSubscriptionRequest)を使用して，受信アドレスへのデポジットをチェックすることをお勧めします．[`getUserHistory()`メソッド](../references/grpc-api-reference.md#hub.rpc.GetUserHistoryRequest) を使用して，どの使用済みアドレスに正の残高があるかを確認することもできます． |\n    | `securityLevel` | 使用済みアドレスのセキュリティレベル | デフォルトのセキュリティレベルは2です．[`keySecLevel` コマンドラインオプション](../references/command-line-options.md#keySecLevel)のセキュリティレベルを変更した場合は，必ず `securityLevel` を使用してください． |\n    | `value` | `inputAddress` フィールドの使用済みアドレスの合計残高 | [thetangle.org](https://thetangle.org/) などのタングルエクスプローラーでアドレスの残高を確認できます． |\n\n    <!-- |**Field**|**Description**|**Notes**| -->\n    <!-- |:----|:----------|:-----------| -->\n    <!-- |`outputAddress`|The new 81-tryte address (without a checksum) to which you want to transfer the IOTA tokens from the spent address|This address does not need to be a Hub address. For example, you may want to send the tokens to an address on a hardware wallet. | -->\n    <!-- |`inputAddress`|The spent 81-tryte address (without a checksum) that contains the IOTA tokens that you need to recover|It's best practice to use the [`balanceSubscription()` method](../references/grpc-api-reference.md#hub.rpc.BalanceSubscriptionRequest) to check for incoming deposits into spent addresses. You can also use the [`getUserHistory()` method](../references/grpc-api-reference.md#hub.rpc.GetUserHistoryRequest) to check which spent addresses have a positive balance.| -->\n    <!-- |`securityLevel`| The security level of the spent address|The default security level is 2. If you changed the security level in the [`keySecLevel` command-line option](../references/command-line-options.md#keySecLevel), make sure you use that one. | -->\n    <!-- |`value`|The total balance of the spent address in the `inputAddress` field|You can check the balance of any address on a Tangle explorer such as [thetangle.org](https://thetangle.org/) | -->\n\n    :::info:\n    `createUnsignedBundle()` 関数が `signature fragment` を追加できる十分なゼロトークントランザクションを作成できるように，スウィープアドレスのセキュリティレベルが必要です．\n    :::\n    <!-- :::info: -->\n    <!-- You need the security level of the spent address so that the `createUnsignedBundle()` function can create enough zero-value transactions to which you can add the signature fragments. -->\n    <!-- ::: -->\n\n    ```js\n    let outputAddress = Converter.trytesToTrits('ADDRESS...');\n    let inputAddress = Converter.trytesToTrits('ADDRESS...');\n\n    const params = {\n      outputAddress: outputAddress,\n      inputAddress: inputAddress,\n      securityLevel: 2,\n      value: 1\n    }\n    ```\n\n3. `createUnsignedBundle()` 関数を呼び出し，ハブから取得したパラメーターを渡します．\n  <!-- 3. Call the `createUnsignedBundle()` function, and pass it the parameters you got from Hub -->\n\n    ```js\n    createUnsignedBundle(parameters);\n    ```\n\n    この関数は，現在のディレクトリにある `bundle` と呼ばれるバイナリファイルに未署名のバンドルを保存します．\n    <!-- This function saves the unsigned bundle to a binary file called `bundle` in your current directory. -->\n\n4. ファイルを実行し，未署名のバンドルハッシュをコンソールからクリップボードにコピーします．ハブは，署名を作成するためにこのバンドルハッシュを必要とします．\n  <!-- 4. Execute the file, then copy the unsigned bundle hash from the console to the clipboard. Hub needs this bundle hash to create the signature. -->\n\n## 手順2. ハブを使用して未署名のバンドルに署名する\n<!-- ## Step 2. Use Hub to sign the unsigned bundle -->\n\nハブには `signBundle()` gRPC メソッドがあり，ユーザーのデポジットアドレスから IOTA トークンを取り出すバンドルに署名できます．\n<!-- Hub has a `signBundle()` gRPC method, which allows you to sign bundles that withdraw from a user's deposit address. -->\n\n1. ハブで，未署名のバンドルハッシュとスウィープしたアドレスを `signBundle()` メソッドに渡します．\n  <!-- 1. In Hub, pass the unsigned bundle hash and the spent address to the `signBundle()` method -->\n\n    ```bash\n    Hub@localhost:50051> client.signBundle({address:'ADDRESS...',bundleHash:'BUNDLEHASH...',authentication:'',validateChecksum:false},pr)\n    ```\n\n2. 返された署名をコピーし，`trytesToTrits()` メソッドにペーストして，トライトに変換します．\n  <!-- 2. Copy the returned signature and paste it into the `trytesToTrits()` method to convert it to trits -->\n\n    ```js\n    const signature = Converter.trytesToTrits('SIGNATURE...')\n    ```\n\n3. 前に保存した `bundle` ファイルから未署名のバンドルを読み取ります．\n  <!-- 3. Read the unsigned bundle from the `bundle` file you saved earlier -->\n\n    ```js\n    bundle = new Int8Array(fs.readFileSync('bundle'));\n    ```\n\n4. 署名を未署名のバンドルに追加します．\n  <!-- 4. Add the signature to the unsigned bundle -->\n\n    ```js\n    bundle.set(Bundle.addSignatureOrMessage(bundle, signature, 1));\n    ```\n\n    :::info:\n    3番目の引数は，署名フラグメントの追加を開始するバンドル内の最初のトランザクションを指定します．この例では，最初のトランザクションは出力トランザクションであるため，署名は必要ありません．\n    :::\n    <!-- :::info: -->\n    <!-- The third argument specifies the first transaction in the bundle to which to start adding the signature fragments. In our example, the first transaction is the output transaction, so it doesn't need a signature. -->\n    <!-- ::: -->\n\n## 手順3. 署名済みバンドルをノードに送信する\n<!-- ## Step 3. Send the signed bundle to a node -->\n\nバンドル内の入力トランザクションに署名フラグメントを追加すると，バンドルは署名され，ノードに送信する準備が整います．\n<!-- After adding the signature fragments to the input transactions in your bundle, it's now signed and ready to be sent to a node. -->\n\n1. 署名済みバンドル内のトランザクションをトライトに変換し，それらを新しい配列にプッシュします．\n  <!-- 1. Convert the transactions in the signed bundle to trytes and push them into a new array -->\n\n    ```js\n    const trytes = []\n    for (let offset = 0; offset < bundle.length; offset += Transaction.TRANSACTION_LENGTH) {\n      trytes.push(Converter.tritsToTrytes(bundle.subarray(offset, offset + Transaction.TRANSACTION_LENGTH)));\n    }\n    ```\n\n2. `provider` フィールドに URL を追加して，ノードに接続します．\n  <!-- 2. Connect to a node by adding the URL of one to the `provider` field -->\n\n    ```js\n    const iota = Iota.composeAPI({\n      provider: ''\n    });\n    ```\n\n3. ノード構成オプションを設定します．\n  <!-- 3. Set the node configuration options -->\n\n    ```js\n    const depth = 3;\n    const minWeightMagnitude = 14;\n    ```\n\n4. バンドルのトランザクショントライトをノードに送信します．\n  <!-- 4. Send the bundle's transaction trytes to the node -->\n\n    ```js\n    iota.sendTrytes(trytes.reverse(), depth, minWeightMagnitude)\n    .then(bundle => {\n      console.log(`Sent bundle: ${JSON.stringify(bundle, null, 1)}`)\n    })\n    .catch(error => {\n      console.log(error);\n    });\n    ```\n\n    :::info:\n    ここで，ノードはバンドルの先頭トランザクションから先に送信されることを期待しているため，トランザクショントライト配列を逆にします．\n    :::\n    <!-- :::info: -->\n    <!-- Here, we reverse the transaction trytes array because nodes expect a bundle to be sent head first. -->\n    <!-- ::: -->\n\n:::success:おめでとうございます:tada:\n使用済みアドレスから IOTA トークンを安全なアドレスにデポジットしてリカバーする署名付きバンドルを送信しました．\n:::\n<!-- :::success: -->\n<!-- You've sent a signed bundle that recovers IOTA tokens from a spent address by depositing them into a safe one. -->\n<!-- ::: -->\n\n:::warning:\nバンドルが確定されるまで，IOTA トークンは攻撃者によって取り出される危険性があります．\n\nバンドルが確定される可能性を高めるには，[プロモートと再アタッチ](/docs/client-libraries/0.1/how-to-guides/js/confirm-pending-bundle)を行います．\n:::\n<!-- :::warning: -->\n<!-- Until the bundle is confirmed, the tokens are still at risk of being withdrawn by an attacker. -->\n<!--  -->\n<!-- To increase the chances of your bundle being confirmed, you can [promote and reattach it](/docs/client-libraries/0.1/how-to-guides/js/confirm-pending-bundle). -->\n<!-- ::: -->\n\n## サンプルコード\n<!-- ## Sample code -->\n\nこれは，このチュートリアルのテストに使用した使用済みアドレスの例のコードです．\n<!-- This is the code for an example spent address that we used to test this tutorial. -->\n\nタングルエクスプローラーで[このアドレスの履歴を表示](https://thetangle.org/address/LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD)できます．\n<!-- You can [see the history of this address](https://thetangle.org/address/LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD) on a Tangle explorer. -->\n\n```js\nconst Iota = require('@iota/core');\nconst Bundle = require('@iota/bundle');\nconst Transaction = require('@iota/transaction');\nconst Converter = require('@iota/converter');\nconst fs = require('fs');\n\nasync function createUnsignedBundle({ outputAddress, inputAddress, securityLevel, value }) {\n  let bundle = new Int8Array();\n  const issuanceTimestamp = Converter.valueToTrits(Math.floor(Date.now() / 1000));\n\n  bundle = Bundle.addEntry(bundle, {\n    address: outputAddress,\n    value: Converter.valueToTrits(value),\n    issuanceTimestamp\n  });\n\n  // セキュリティレベルごとに，残りの署名フラグメントを追加する新しいゼロトークントランザクションが必要です．\n  for (let i = 0; i < securityLevel; i++) {\n    bundle = Bundle.addEntry(bundle, {\n      address: inputAddress,\n      value: Converter.valueToTrits(i == 0 ? -value : 0),\n      issuanceTimestamp\n    });\n  }\n\n  const result = await Bundle.finalizeBundle(bundle);\n\n  fs.writeFileSync('bundle', result, (error) => {\n    if(!error) {\n      console.log('Bundle details saved to file');\n    } else{\n      console.log(`Error writing file: ${error}`);\n    }});\n\n  // バンドルハッシュのトライトを取得します．\n  const bundleHash = Converter.tritsToTrytes(Transaction.bundle(result));\n\n  // ハブでバンドルハッシュを使用して署名を取得します．\n  console.log(bundleHash);\n}\n\n// これらのパラメーターの値をハブから取得します．\n\nlet outputAddress = Converter.trytesToTrits('LYRGKMBCVZMTPRRMPDNNRXFVKIXTZCJTZDOAMTHZXQNESSLYGVQ99PGAW9OCAPRGSSSDMFCMZ9NAJTWUX');\nlet inputAddress = Converter.trytesToTrits('LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD');\n\nconst params = {\n  // 使用済みアドレスから IOTA トークンを送信する先のトライトのアドレス（チェックサムなし）\n  outputAddress: outputAddress,\n  // 使用済みアドレスのトライト（チェックサムなし）\n  inputAddress: inputAddress,\n  // 使用済みアドレスのセキュリティレベル\n  securityLevel: 2,\n  // 使用済みアドレスから取り出される IOTA トークンの合計量\n  value: 1\n}\n\ncreateUnsignedBundle(params);\n\n// トライトでハブからの署名に置き換えます．\nconst signature = Converter.trytesToTrits(\"DRFFHLSWJBLEBNHXMSLIGUKBQJIJRNHGMGVDFKKPF9DYABMQXDVLWPHXT9LEPSXVBIYKZEWCT9U99NJ9DQJVJJMBGCUHTZQBCYWEIN9DCSDPJXRKGQQBEHPBZZWRFNBIENYV9UNSSNXZHGATAWRTHEW9FQVTXUJLFCQEPLVWATFRXFAUSNFKVVYFISDULSVIQNEQVPNIKZSBJQHWAZMGOIPZSKY9QDVMCFXUS9UGUDK9BOZFAWXQFHFBEYUJBESIFMBWNXVFCKHTGXTWKLSMZ9FHYFUZKE9GTLFWXPCLFPQKCJQAZFSTGWJILTACIXLRRJWDGIGJOCTUCEBFLWFQBQKAHTJMAEWZSDMOTQ9GPALHYYRGTFYJCDRFKZFUPECKUEVZJPVQDYIDJAIHSFSWZSQLQIJSCKJPJPLFVHXLUMLZKUHJWRVPBIOESDIFCUCKZAGANIATOUCSF9IOUA9EQWCSOFMETZEADESOADJGLCDKUQIBEPMXBWNIHJMJHCYUSM9LXMEBTHORZDGYST9VJLUUSXTSAURNUZAUPNWIUSRVL9KGFCEIAIWTNIH9BIRCSLWDAPXYKSZAOFERYFGPBWYUIEEENGMMYVPRRRIXULRJWJCLUBBNMNLFMNPYDHVBFZUFRCD9PCZAQLDBJFFKGQJW9LFUUPIZPKUCBAJFUEUTMXKWUKFXKQISDXYIHEJSQTCEHVABAUWGGANWZCNBOLGZDCLXSZIUKRMFG9THEZTULVZ9CFGNUWCTQVSACVYSZASONJIGUSXZAZNVCBIWRHLOKCXPXFONAWNMWRMGAXXJNPYRNDKAKIEWNSDRSNTSTMDPUYNPSIJTWERECFKSNTWOKCMDIUEKEYXORVIQVQXKWOWNMVBLWVJIWBWKAHHECGLNZAADFVSATZDMLYXBGRCEATLTCMQACYQQDQOXXMSUWSZVZKEXQUYM9DZMMOMBIVCPJU9UUKAXOSQQX9QRPTFXSZPBZFFJLGOBVZZOT9LNWMA9LTRUZUJBDGH9GILESQLNYDYPCHHYICVMAPDVDILEOZDNZMVSERSDWLZ9ZXFKJXISY9BLXZZ9DJYIRPXNLGAWMDZOXOWBUDZRUROHKPREZJTXNSUNC9LDHGFLGYOXBAQVGYUZXECCKUUFOPSLPH9QRLAZUOWGBQBVEJBAZKUEWSUIVGLEULZKDXFQSGQNZYXXZCYPRZUSBPMVPLWMYDWEGXANNXLOTME9HQGQW9POKCSQWHLHUUUWNFFHXZYDYUYBMSJVWSAKMEFJDJNJZHIYP9NBLFWVKBSDIUXLAVLMYLLCRX9BZZZQEESERVDIHKKPVAM9UEOXR9CFW9OAXLCLMJHWEOSTCYYHPWHJZEKAXPBGNGVMCGNHOUWMJX9GEV9BBGYVNEG9AXSNPFEGOZNZWXMNXVV9CVJ9Z9DGLYOUWZKFJYIIWRUEYPGDFSJGRXZDS9RKFELFVMASCAPXVCPLNQRJHADACOOGGHOVTTG9DCOCMHTMTMNEVASXHKLBAWKNFTFDAEEHATXGUKBRLDXNLSHZEPO9OZQBSHJRLGLNPKHAX9WRMYARVJETYAPO9SUWZQHAKJAUWBIWQDSQ9FWIEWSJWKQGNIFGGVKZLWZZOVVBGPNRTONMZDLJHGWQUSCILYOBG9YUUUZDXILKBIQ9ZEKXEHURJLFMDB9CUZI9TEJSQZYHMNTX9F9GJBZ9UJNCKZVYAROOVZYZURRWKLYHJEMZDQLH9FWODFZUEZRV9DWNZCOMXNXFWCPCZQDGFP9DKJYUNXIYIRUVWRSWWIGKZWITSYIVEOPHBJGSZNYJSFTXAKLENHCPGOYQSGEZQMRVNFGAGZXFG9GYFIBJRVU9MYDSZSTJQVVODQJJEHYJYCHOHTCOPZJVGMBEIIGYFMNAPZATAHQGFVWSGYODTOHRE9FVYXSLESASDMMAPBZZVPLIWGIRORAGWNFA9JPSUWJCTNBYRDJANSYMNDGQJNSFQRSVMRIAXDWQONWSAYUYFXJUTWYLPXVV9YGJBMQUXODSEFAEGYXSYYEQTVRAWNCKKSWPRYYINMBOBNZJSANFLKDFMGTNUDU9SFQRBUJM9XDNWIECTJPEICLVXTMCMGQJT9BTRZ9HQCHHBYXSPJBGTSTJDIOUQ9SLRVHTENSCLLGBFMXOYFKYB9SAKWTPGHEXPU9ERFYGEMEPSLJUPRJNRRWQLA9XVSWBEGJHLLDXGDTESDPRBRQHLCIOPWBDYJVCLOHHDYFNQSXBOVUVICSVBMEZYJJZHGDKAHFRJHBDWUSFSGC9UCLVH9ZNVMPYMRMMJTSWAFDRGNALYLRRVPLGMMKGZR9LXEV9ZXRPFKYDBLIUEVEJKVDANOBKFLRSWQPMOMTEJA9WVHFGBNTAJIPWNUWKJMQAOKBCACLYGRCBZRVFKIOMCXYXGUTNODHMLOZRETEPDONTAPVQEQAWCAH9CSTPYRFUXPKBDVONWFNOZHA9N9YUTEIGAHAPEKNWGCXNAMVJVLPCAPDPNTVVSKROYWXDKVLOAHPCCJBGBPSMQEDFDXSGNMIMLEZPBVCKYKVZFFIZVECYQKQWDHXRVEAOL9QIDZK9JFBRYL9JOSAWMBZAXJWNBTLKRSIYHZEILOPRZVLOFACJGIPABPFZILVQMUAYMPABXEBDYOSYBZKUXCFVXUEQJJOUDMBZZGOBVBF9N9ENHSCTDVFASKXHOLLFYMMWSDFHJKHODXYPWMEOQZKIECIBHYXF9PXZOCBMIBI9PLVDVBGALAWBT9FLIZWRNENVLSUCSOATNVRUKTTWZNTZRCMTLALKYGOUKVSO9BBUDVUCFCIKQZWJIUBMXTSNQSFRETWAHPQ9MTYOUKX9BLA9QUUHPNLNINNIPWQVUPUCXHTMURNWYSUGOKWPYMZ9ILDJWEOD9D99YWKQTKKOOWQOLEZMTZ99AYQPWUVVZUNVORK9XRAE9GQSHLVIZLCEDWHSWYNVZKELOI9AVGUWFSJYHA9WZNVNZYFEZYJAXKUOPINHR9OEN9NVLNIDEJLPLVEMIANSGFXXXL9IKQAFLFPOPWO9SAEMNETZMUM9NEHAA9JOGLHOBHYHXASFWHGNKCRNWZSCDPIFGFHOFLWCOMNCPRBECDEVSNXGKNF9IOYIVZRBJJHCREKOFHMTXXALIWOGOZRIJITCWGKQKCVUPUOFNMEUGSVPYAKRORXQHUXJVCAEWJBLAPDDSCIYMODOMM9GWQSVQUBGBUUDVGSSHAONRHVMILHPMBHKKHUTRZFWNAEEUHCQUGHLSVXAMOGVTXELPGKXBHELPCGYRCLMYGIZYLANN9LSXCQVQPBLIZXJUVRTA9CQAFSWWTIBILERJDTYHJWDPOYHNCHJEWSVXEJCPZVNVLWWOAZHJLLTS9WAEXXSMWHITJYJLFHGGDFNYIGDKJFUZGSJDCXSVNZQYUSAPVJRHSRNLNQDLDBEFPLRXJ9MIZBPNBZVHHLOYC9VYLDKNJAHLNPRCSOZKHWHQKXYWXABCPHYNQYRZJEARZCOLQMBCJCHNNSFGORUOHFOFJMF9MJHHFFVBCS9QITDPGXTJKDDJKHGBOLEVMXRAWUMCXUABILEYVHRTZFFMAM9REMUPNEPUHKWFHOJEFBLXXYHI99UDFMXLXEFWQLPTKJJQEQAXYCQNCZMMOTSKGQCJNFCWGUISHWZLDWJBNNAFDDOMOJ9QRVDEXXNHLKVP9CQJSGZRT9CHDTUJIXWM9WB9RTYQ9EEIJWEVSGKQPFLKG9HKNWSGWZUAGOBENKKT9NUMUIAPWZ9UESGRDITJSOMJAPHIN9CJSSUJCAKCLTQPJOUEMKVLSZZ9MAEROPNSBHPHOFBVVOSNTWPSCRTAYQJQSG9YXPRMAHREBCQKMRFISYDXXNRMGEHCXFNH9SAGFOYAHFCQRNQFRXDIJAIBIRPBNVQZLZNJHBVCZHOIHJURHCFFVHFCPBSKGLQOCXKWXSFINGLYQAH9YGPFWJGQDOUIMFJJOFGNDREMEIMDKOEQONGHTVYWVXWHQQOJGCM9YEHBCVWNJLJXK9HQB9BDYTUJVTHYU9R9DPMUHTLB9NGFEEVKIUANTFHUQRRK9LSSFMUBZLKJTJLPQLBEUSVAFJURBSGFNMBZCDKEUTCNYHBZPUCZGQDAP9JISCORGZVTMLCFRDHKJBCEOYOHEHUDTHMGHMFDTPKGNQPCIBTSOCISWKFSMPDVUKPAWVACALATUSWJTJPXHJWUFDEICUNUDSHGYEGRPMDRABLMFCHXNUA9LHNUMDKXH99XGJKU9XMUXFOXKWLI9AFNDD9CSETSFB9MLEMEY9UMHQQYROBZZEBGHRQRERMHILEVEGNOBSFUIIIJZHRFPOBXHGRSXPYEC\");\n\nbundle = new Int8Array(fs.readFileSync('bundle'));\n\n// トランザクション0は出力トランザクションなので，バンドル内の次のトランザクションから署名フラグメントの追加を開始します．\nbundle.set(Bundle.addSignatureOrMessage(bundle, signature, 1));\n\nconst trytes = []\nfor (let offset = 0; offset < bundle.length; offset += Transaction.TRANSACTION_LENGTH) {\n  trytes.push(Converter.tritsToTrytes(bundle.subarray(offset, offset + Transaction.TRANSACTION_LENGTH)));\n}\n\nconst iota = Iota.composeAPI({\n  // トランザクションを送信する IRI ノードの URL に置き換えます．\n  provider: 'https://pow.iota.community:443'\n});\n\nconst depth = 3;\nconst minWeightMagnitude = 14;\n\n// バンドルは，ノードに送信する前に先頭トランザクションから末尾トランザクションまで順番に並んでいる必要があります．\niota.sendTrytes(trytes.reverse(), depth, minWeightMagnitude)\n  .then(bundle => {\n    console.log(`Sent bundle: ${JSON.stringify(bundle, null, 1)}`)\n  })\n  .catch(error => {\n    console.log(error);\n  });\n```\n","title":"使用済みアドレスから IOTA トークンをリカバーする | ハウツーガイド | ハブ | ウォレット"}}
