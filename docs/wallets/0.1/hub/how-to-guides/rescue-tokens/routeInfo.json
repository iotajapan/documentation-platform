{"path":"docs/wallets/0.1/hub/how-to-guides/rescue-tokens","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# スウィープしたアドレスからIOTAトークンを救う\n<!-- # Rescue IOTA tokens from a swept address -->\n\n**Winternitzワンタイム署名スキームは、アドレスからIOTAトークンを取り出すバンドルに署名するために使用されます。その結果、アドレスは1度だけならIOTAトークンを取り出しても安全です。ハブがアドレスをスウィープした後、そのアドレスは使用済みになり、そのアドレスから再び取り出しを行なってはいけません。ただし、ユーザーはIOTAトークンを、既にスウィープした古い預け入れアドレスに送信する場合があります。この場合、攻撃者が署名に対して総当たり攻撃を行いIOTAトークンを盗もうとするリスクがあります。スウィープしたアドレスからIOTAトークンを救うために、潜在的な攻撃者が総当たり攻撃を仕掛ける前にIOTAトークンを新しいアドレスに転送しようとすることができます。**\n<!-- **The Winternitz one-time signature scheme is used to sign bundles that withdraw IOTA tokens from addresses. As a result, addresses are safe to withdraw from only once. After Hub sweeps an address, that address is spent and must never be withdrawn from again. But, sometimes users send IOTA tokens to old deposit addresses that have already been swept. In this case, the address is at risk of an attacker trying to brute force its signature to steal its tokens. To rescue the tokens from the swept address, you can try to transfer them to a new address before a potential attacker can.** -->\n\nスウィープしたアドレスからIOTAトークンを救うには、ハブの外部で未署名のバンドルを作成し、ハブを使用してそのバンドルに署名してから、完全なバンドルをノードに送信する必要があります。\n<!-- To rescue tokens from a swept address, you must create an unsigned bundle outside of Hub, use Hub to sign it, then send the complete bundle to a node. -->\n\nこのガイドでは、JavaScriptクライアントライブラリを使用してバンドルを作成および送信しますが、Go、Java、Pythonなどの他の[公式およびコミュニティライブラリ](/docs/client-libraries/0.1/introduction/overview)もあります。\n<!-- In this guide, we use the JavaScript client library to create and send the bundle, but we also have other [official and community libraries](/docs/client-libraries/0.1/introduction/overview), including Go, Java, and Python. -->\n\n## 前提条件\n<!-- ## Prerequisites -->\n\nこのガイドを完了するには、次のものが必要です。\n<!-- To complete this guide, you need the following: -->\n\n* Node.js 8、またはNode.js 10以降。 [最新のLTS](https://nodejs.org/en/download/)をお勧めします。\n<!-- * Node.js 8, or Node.js 10 or higher. We recommend the [latest LTS](https://nodejs.org/en/download/). -->\n* [Visual Studio Code](https://code.visualstudio.com/Download)などのコードエディター\n<!-- * A code editor such as [Visual Studio Code](https://code.visualstudio.com/Download) -->\n* コマンドプロンプトへのアクセス\n<!-- * Access to a command prompt -->\n* インターネット接続\n<!-- * An Internet connection -->\n* [`@iota/bundle`](https://github.com/iotaledger/iota.js/tree/next/packages/bundle), [`@iota/core`](https://github.com/iotaledger/iota.js/tree/next/packages/core), [`@iota/converter`](https://github.com/iotaledger/iota.js/tree/next/packages/converter), および[`@iota/transaction`](https://github.com/iotaledger/iota.js/tree/next/packages/transaction)パッケージ\n<!-- * The [`@iota/bundle`](https://github.com/iotaledger/iota.js/tree/next/packages/bundle), [`@iota/core`](https://github.com/iotaledger/iota.js/tree/next/packages/core), [`@iota/converter`](https://github.com/iotaledger/iota.js/tree/next/packages/converter), and [`@iota/transaction`](https://github.com/iotaledger/iota.js/tree/next/packages/transaction) packages -->\n* ハブの[`SignBundle_enabled`フラグ](../references/command-line-flags.md#signBundle)が`true`に設定されていることを確認します。\n<!-- * Make sure that Hub's [`SignBundle_enabled` flag](../references/command-line-flags.md#signBundle) is set to `true`. -->\n\n:::info:\nIOTAクライアントライブラリを使用したことがない場合は、[入門チュートリアル](/docs/getting-started/0.1/tutorials/send-a-zero-value-transaction-with-nodejs)を完了することをお勧めします。\n:::\n<!-- :::info: -->\n<!-- If you've never used the IOTA client libraries before, we recommend completing [the getting started tutorial](/docs/getting-started/0.1/tutorials/send-a-zero-value-transaction-with-nodejs) -->\n<!-- ::: -->\n\n## 手順1. 未署名のバンドルを作成する\n<!-- ## Step 1. Create an unsigned bundle -->\n\nハブがバンドルに署名する前に、未署名のバンドルを作成する必要があります。\n<!-- Before Hub can sign a bundle, you need to create an unsigned one. -->\n\n1. パッケージを要求します。\n  <!-- 1. Require the packages -->\n\n    ```js\n    const Iota = require('@iota/core');\n    const Bundle = require('@iota/bundle');\n    const Transaction = require('@iota/transaction');\n    const Converter = require('@iota/converter');\n    ```\n\n2. 未署名のバンドルを作成して保存するために、`createUnsignedBundle()`関数を作成します。\n  <!-- 2. Create a `createUnsignedBundle()` function to create and save an unsigned bundle -->\n\n    ```js\n    async function createUnsignedBundle({ outputAddress, inputAddress, securityLevel, value }) {\n    let bundle = new Int8Array();\n    const issuanceTimestamp = Converter.valueToTrits(Math.floor(Date.now() / 1000));\n\n    bundle = Bundle.addEntry(bundle, {\n      address: outputAddress,\n      value: Converter.valueToTrits(value),\n      issuanceTimestamp\n    });\n\n    // For every security level, create a new zero-value transaction to which you can later add the rest of the signature fragments\n    for (let i = 0; i < securityLevel; i++) {\n      bundle = Bundle.addEntry(bundle, {\n        address: inputAddress,\n        value: Converter.valueToTrits(i == 0 ? -value : 0),\n        issuanceTimestamp\n      });\n    }\n\n    const result = await Bundle.finalizeBundle(bundle);\n\n    // Save the bundle array to a binary file\n    fs.writeFileSync('bundle', result, (error) => {\n      if(!error) {\n        console.log('Bundle details saved to file');\n      } else{\n        console.log(`Error writing file: ${error}`);\n      }});\n\n    const bundleHash = Converter.tritsToTrytes(Transaction.bundle(result));\n\n    console.log(bundleHash);\n    }\n    ```\n\n3. ハブから次の値を取得し、それらを`parameters`オブジェクトに追加します。\n  <!-- 3. Get the following values from Hub and add them to the `parameters` object: -->\n\n    | **フィールド** | **説明** | **メモ** |\n    | :------------- | :------- | :------- |\n    | `outputAddress` | スウィープアドレス上のIOTAトークンを転送する新しい81トライトのアドレス（チェックサムなし） | このアドレスは、ハブアドレスである必要はありません。たとえば、IOTAトークンをハードウェアウォレットのアドレスに送信できます。 |\n    | `inputAddress` | 救う必要があるIOTAトークンを含む、スウィープした81トライトのアドレス（チェックサムなし） | [`balanceSubscription()`メソッド](../references/api-reference.md#hub.rpc.BalanceSubscriptionRequest)を使用して、受信アドレスへの預け入れをチェックすることをお勧めします。[`getUserHistory()`メソッド](../references/api-reference.md#hub.rpc.GetUserHistoryRequest)を使用して、どの使用済みアドレスに正のバランスがあるかを確認することもできます。 |\n    | `securityLevel` | スウィープアドレスのセキュリティレベル | デフォルトのセキュリティレベルは2です。[`keySecLevel`コマンドラインフラグ](../references/command-line-flags.md#keySec)のセキュリティレベルを変更した場合は、必ずそれを使用します。 |\n    | `value` | `inputAddress`フィールドのスウィープアドレスの合計残高 | [thetangle.org](https://thetangle.org/)などのタングルエクスプローラーでアドレスの残高を確認できます。 |\n\n    <!-- |**Field**|**Description**|**Notes**| -->\n    <!-- |:----|:----------|:-----------| -->\n    <!-- |`outputAddress`|The new 81-tryte address (without a checksum) to which you want to transfer the tokens on the swept address|This address does not need to be a Hub address. For example, you may want to send the tokens to an address on a hardware wallet. | -->\n    <!-- |`inputAddress`|The swept 81-tryte address (without a checksum) that contains the IOTA tokens that you need to rescue|It's best practice to use the [`balanceSubscription()` method](../references/api-reference.md#hub.rpc.BalanceSubscriptionRequest) to check for incoming deposits into swept addresses. You can also use the [`getUserHistory()` method](../references/api-reference.md#hub.rpc.GetUserHistoryRequest) to check which spent addresses have a positive balance.| -->\n    <!-- |`securityLevel`| The security level of the swept address|The default security level is 2. If you changed the security level in the [`keySecLevel` command-line flag](../references/command-line-flags.md#keySec), make sure you use that one. | -->\n    <!-- |`value`|The total balance of the swept address in the `inputAddress` field|You can check the balance of any address on a Tangle explorer such as [thetangle.org](https://thetangle.org/) | -->\n\n    :::info:\n    `createUnsignedBundle()`関数が[signature fragment](/docs/dev-essentials/0.1/concepts/addresses-and-signatures#signatures)を追加できる十分なゼロトークントランザクションを作成できるように、スウィープアドレスのセキュリティレベルが必要です。\n    :::\n    <!-- :::info: -->\n    <!-- You need the security level of the swept address so that the `createUnsignedBundle()` function can create enough zero-value transactions to which you can add the [signature fragments](/docs/dev-essentials/0.1/concepts/addresses-and-signatures#signatures). -->\n    <!-- ::: -->\n\n    ```js\n    let outputAddress = Converter.trytesToTrits('ADDRESS...');\n    let inputAddress = Converter.trytesToTrits('ADDRESS...');\n\n    const params = {\n      outputAddress: outputAddress,\n      inputAddress: inputAddress,\n      securityLevel: 2,\n      value: 1\n    }\n    ```\n\n2. `createUnsignedBundle()`関数を呼び出し、ハブから取得したパラメーターを渡します。\n  <!-- 2. Call the `createUnsignedBundle()` function, and pass it the parameters you got from Hub -->\n\n    ```js\n    createUnsignedBundle(parameters);\n    ```\n\n    この関数は、現在のディレクトリにある`bundle`と呼ばれるバイナリファイルに未署名のバンドルを保存します。\n    <!-- This function saves the unsigned bundle to a binary file called `bundle` in your current directory. -->\n\n3. ファイルを実行し、未署名のバンドルハッシュをコンソールからクリップボードにコピーします。ハブは、署名を作成するためにこのバンドルハッシュを必要とします。\n  <!-- 3. Execute the file, then copy the unsigned bundle hash from the console to the clipboard. Hub needs this bundle hash to create the signature. -->\n\n## 手順2. ハブを使用して未署名のバンドルに署名する\n<!-- ## Step 2. Use Hub to sign the unsigned bundle -->\n\nHubには`signBundle()`gRPCメソッドがあり、ハブユーザーのアドレスから取り出しバンドルに署名できます。\n<!-- Hub has a `signBundle()` gRPC method that allows you to sign bundles that withdraw from a Hub user's address. -->\n\n:::info:\n`signBundle()`メソッドを使用する前に、ハブの[`SignBundle_enabled`フラグ](../references/command-line-flags.md#signBundle)が`true`に設定されていることを確認します。\n:::\n<!-- :::info: -->\n<!-- Before you use the `signBundle()` method, make sure that Hub's [`SignBundle_enabled` flag](../references/command-line-flags.md#signBundle) is set to `true`. -->\n<!-- ::: -->\n\n1. ハブで、未署名のバンドルハッシュとスウィープしたアドレスを`signBundle()`メソッドに渡します。\n  <!-- 1. In Hub, pass the unsigned bundle hash and the swept address to the `signBundle()` method -->\n\n    ```bash\n    Hub@localhost:50051> client.signBundle({address:'ADDRESS...',bundleHash:'BUNDLEHASH...',authentication:'',validateChecksum:false},pr)\n    ```\n\n2. 返された署名をコピーし、`trytesToTrits()`メソッドにペーストして、トライトに変換します。\n  <!-- 2. Copy the returned signature and paste it into the `trytesToTrits()` method to convert it to trits -->\n\n    ```js\n    const signature = Converter.trytesToTrits('SIGNATURE...')\n    ```\n\n3. 前に保存した`bundle`ファイルから未署名のバンドルを読み取ります。\n  <!-- 3. Read the unsigned bundle from the `bundle` file you saved earlier -->\n\n    ```js\n    bundle = new Int8Array(fs.readFileSync('bundle'));\n    ```\n\n4. 署名を未署名のバンドルに追加します。\n  <!-- 4. Add the signature to the unsigned bundle -->\n\n    ```js\n    bundle.set(Bundle.addSignatureOrMessage(bundle, signature, 1));\n    ```\n\n    :::info:\n    3番目の引数は、署名フラグメントの追加を開始するバンドル内の最初のトランザクションを指定します。この例では、最初のトランザクションは出力トランザクションであるため、署名は必要ありません。\n    :::\n    <!-- :::info: -->\n    <!-- The third argument specifies the first transaction in the bundle to which to start adding the signature fragments. In our example, the first transaction is the output transaction, so it doesn't need a signature. -->\n    <!-- ::: -->\n\n## 手順3. 署名済みバンドルをノードに送信する\n<!-- ## Step 3. Send the signed bundle to a node -->\n\nバンドル内の入力トランザクションに署名フラグメントを追加すると、バンドルは署名され、ノードに送信する準備が整います。\n<!-- After adding the signature fragments to the input transactions in your bundle, it's now signed and ready to be sent to a node. -->\n\n1. 署名済みバンドル内のトランザクションをトライトに変換し、それらを新しい配列にプッシュします。\n  <!-- 1. Convert the transactions in the signed bundle to trytes and push them into a new array -->\n\n    ```js\n    const trytes = []\n    for (let offset = 0; offset < bundle.length; offset += Transaction.TRANSACTION_LENGTH) {\n      trytes.push(Converter.tritsToTrytes(bundle.subarray(offset, offset + Transaction.TRANSACTION_LENGTH)));\n    }\n    ```\n\n2. `provider`フィールドにURLを追加して、ノードに接続します。\n  <!-- 2. Connect to a node by adding the URL of one to the `provider` field -->\n\n    ```js\n    const iota = Iota.composeAPI({\n      provider: ''\n    });\n    ```\n\n3. ノード構成オプションを設定します。\n  <!-- 3. Set the node configuration options -->\n\n    ```js\n    const depth = 3;\n    const minWeightMagnitude = 14;\n    ```\n\n    :::info:Depth\n    `depth`引数は[チップ選択](/docs/node-software/0.1/iri/concepts/tip-selection)に影響します。`depth`が大きいほど、タングルの奥に戻り、重み付きランダムウォークが始まります。\n    :::\n    <!-- :::info:Depth -->\n    <!-- The `depth` argument affects [tip selection](/docs/node-software/0.1/iri/concepts/tip-selection). The greater the depth, the farther back in the Tangle the weighted random walk starts. -->\n    <!-- ::: -->\n\n    :::info:最小重量値（Minimum weight magnitude）\n    [`最小重量値`](/docs/dev-essentials/0.1/concepts/minimum-weight-magnitude)（MWM）引数は、プルーフオブワーク（PoW）の難易度に影響します。MWMが大きいほど、PoWは難しくなります。\n\n    すべてのIOTAネットワークは、独自のMWMを強制します。Devnetでは、MWMは9です。しかし、Mainnetでは、MWMは14です。小さすぎるMWMを使用すると、トランザクションは有効にならず、確定されません。\n    :::\n    <!-- :::info:Minimum weight magnitude -->\n    <!-- The [`minimum weight magnitude`](/docs/dev-essentials/0.1/concepts/minimum-weight-magnitude) (MWM) argument affects the difficulty of proof of work (PoW). The greater the MWM, the more difficult the PoW. -->\n    <!--  -->\n    <!-- Every IOTA network enforces its own MWM. On the Devnet, the MWM is 9. But, on the Mainnet the MWM is 14. If you use a MWM that's too small, your transactions won't be valid and will never be confirmed. -->\n    <!-- ::: -->\n\n4. バンドルのトランザクショントライトをノードに送信します。\n  <!-- 4. Send the bundle's transaction trytes to the node -->\n\n    ```js\n    iota.sendTrytes(trytes.reverse(), depth, minWeightMagnitude)\n    .then(bundle => {\n      console.log(`Sent bundle: ${JSON.stringify(bundle, null, 1)}`)\n    })\n    .catch(error => {\n      console.log(error);\n    });\n    ```\n\n    :::info:\n    ここで、ノードはバンドルの先頭トランザクションから先に送信されることを期待しているため、トランザクショントライト配列を逆にします。\n    :::\n    <!-- :::info: -->\n    <!-- Here, we reverse the transaction trytes array because nodes expect a bundle to be sent head first. -->\n    <!-- ::: -->\n\n:::success:おめでとうございます:tada:\nスウィープしたアドレスからIOTAトークンを救う署名済みバンドルを送信しました。\n:::\n<!-- :::success: -->\n<!-- You've sent a signed bundle that rescues IOTA tokens from a swept address. -->\n<!-- ::: -->\n\n:::warning:\nバンドルが確定されるまで、IOTAトークンは攻撃者によって取り出される危険性があります。\n\nバンドルが確定される可能性を高めるには、[促進と再添付](/docs/dev-essentials/0.1/how-to-guides/confirm-pending-bundle)を行います。\n:::\n<!-- :::warning: -->\n<!-- Until the bundle is confirmed, the tokens are still at risk of being withdrawn by an attacker. -->\n<!--  -->\n<!-- To increase the chances of your bundle being confirmed, you can [promote and reattach it](/docs/dev-essentials/0.1/how-to-guides/confirm-pending-bundle). -->\n<!-- ::: -->\n\n## サンプルコード\n<!-- ## Sample code -->\n\nこれは、このチュートリアルのテストに使用したスウィープアドレスの例のコードです。\n<!-- This is the code for an example swept address that we used to test this tutorial. -->\n\nタングルエクスプローラーで[このアドレスの履歴を表示](https://thetangle.org/address/LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD)できます。\n<!-- You can [see the history of this address](https://thetangle.org/address/LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD) on a Tangle explorer. -->\n\n```js\nconst Iota = require('@iota/core');\nconst Bundle = require('@iota/bundle');\nconst Transaction = require('@iota/transaction');\nconst Converter = require('@iota/converter');\nconst fs = require('fs');\n\nasync function createUnsignedBundle({ outputAddress, inputAddress, securityLevel, value }) {\n  let bundle = new Int8Array();\n  const issuanceTimestamp = Converter.valueToTrits(Math.floor(Date.now() / 1000));\n\n  bundle = Bundle.addEntry(bundle, {\n    address: outputAddress,\n    value: Converter.valueToTrits(value),\n    issuanceTimestamp\n  });\n\n  // For every security level, we need a new zero-value transaction in which to add the rest of the signature fragments\n  for (let i = 0; i < securityLevel; i++) {\n    bundle = Bundle.addEntry(bundle, {\n      address: inputAddress,\n      value: Converter.valueToTrits(i == 0 ? -value : 0),\n      issuanceTimestamp\n    });\n  }\n\n  const result = await Bundle.finalizeBundle(bundle);\n\n  fs.writeFileSync('bundle', result, (error) => {\n    if(!error) {\n      console.log('Bundle details saved to file');\n    } else{\n      console.log(`Error writing file: ${error}`);\n    }});\n\n  // Get the bundle hash trytes\n  const bundleHash = Converter.tritsToTrytes(Transaction.bundle(result));\n\n  // Use the bundle hash in Hub to get the signature\n  console.log(bundleHash);\n}\n\n// Get the values for these parameters from Hub\n\nlet outputAddress = Converter.trytesToTrits('LYRGKMBCVZMTPRRMPDNNRXFVKIXTZCJTZDOAMTHZXQNESSLYGVQ99PGAW9OCAPRGSSSDMFCMZ9NAJTWUX');\nlet inputAddress = Converter.trytesToTrits('LIQJBJRBSTGYWHYRPCLLCZUMP9SLHCBBWGQ9YRFWYDFF9FMXIAELYLTTBXCPVIDWWZYIOJIFLUFYVZIBD');\n\nconst params = {\n  // Address in trits to send the tokens from the swept address (without checksum)\n  outputAddress: outputAddress,\n  // Swept address in trits (without checksum)\n  inputAddress: inputAddress,\n  // Security level of the swept address\n  securityLevel: 2,\n  // Total amount of IOTA tokens to withdraw from the swept address\n  value: 1\n}\n\ncreateUnsignedBundle(params);\n\n// Replace with the signature from Hub in trits\nconst signature = Converter.trytesToTrits(\"DRFFHLSWJBLEBNHXMSLIGUKBQJIJRNHGMGVDFKKPF9DYABMQXDVLWPHXT9LEPSXVBIYKZEWCT9U99NJ9DQJVJJMBGCUHTZQBCYWEIN9DCSDPJXRKGQQBEHPBZZWRFNBIENYV9UNSSNXZHGATAWRTHEW9FQVTXUJLFCQEPLVWATFRXFAUSNFKVVYFISDULSVIQNEQVPNIKZSBJQHWAZMGOIPZSKY9QDVMCFXUS9UGUDK9BOZFAWXQFHFBEYUJBESIFMBWNXVFCKHTGXTWKLSMZ9FHYFUZKE9GTLFWXPCLFPQKCJQAZFSTGWJILTACIXLRRJWDGIGJOCTUCEBFLWFQBQKAHTJMAEWZSDMOTQ9GPALHYYRGTFYJCDRFKZFUPECKUEVZJPVQDYIDJAIHSFSWZSQLQIJSCKJPJPLFVHXLUMLZKUHJWRVPBIOESDIFCUCKZAGANIATOUCSF9IOUA9EQWCSOFMETZEADESOADJGLCDKUQIBEPMXBWNIHJMJHCYUSM9LXMEBTHORZDGYST9VJLUUSXTSAURNUZAUPNWIUSRVL9KGFCEIAIWTNIH9BIRCSLWDAPXYKSZAOFERYFGPBWYUIEEENGMMYVPRRRIXULRJWJCLUBBNMNLFMNPYDHVBFZUFRCD9PCZAQLDBJFFKGQJW9LFUUPIZPKUCBAJFUEUTMXKWUKFXKQISDXYIHEJSQTCEHVABAUWGGANWZCNBOLGZDCLXSZIUKRMFG9THEZTULVZ9CFGNUWCTQVSACVYSZASONJIGUSXZAZNVCBIWRHLOKCXPXFONAWNMWRMGAXXJNPYRNDKAKIEWNSDRSNTSTMDPUYNPSIJTWERECFKSNTWOKCMDIUEKEYXORVIQVQXKWOWNMVBLWVJIWBWKAHHECGLNZAADFVSATZDMLYXBGRCEATLTCMQACYQQDQOXXMSUWSZVZKEXQUYM9DZMMOMBIVCPJU9UUKAXOSQQX9QRPTFXSZPBZFFJLGOBVZZOT9LNWMA9LTRUZUJBDGH9GILESQLNYDYPCHHYICVMAPDVDILEOZDNZMVSERSDWLZ9ZXFKJXISY9BLXZZ9DJYIRPXNLGAWMDZOXOWBUDZRUROHKPREZJTXNSUNC9LDHGFLGYOXBAQVGYUZXECCKUUFOPSLPH9QRLAZUOWGBQBVEJBAZKUEWSUIVGLEULZKDXFQSGQNZYXXZCYPRZUSBPMVPLWMYDWEGXANNXLOTME9HQGQW9POKCSQWHLHUUUWNFFHXZYDYUYBMSJVWSAKMEFJDJNJZHIYP9NBLFWVKBSDIUXLAVLMYLLCRX9BZZZQEESERVDIHKKPVAM9UEOXR9CFW9OAXLCLMJHWEOSTCYYHPWHJZEKAXPBGNGVMCGNHOUWMJX9GEV9BBGYVNEG9AXSNPFEGOZNZWXMNXVV9CVJ9Z9DGLYOUWZKFJYIIWRUEYPGDFSJGRXZDS9RKFELFVMASCAPXVCPLNQRJHADACOOGGHOVTTG9DCOCMHTMTMNEVASXHKLBAWKNFTFDAEEHATXGUKBRLDXNLSHZEPO9OZQBSHJRLGLNPKHAX9WRMYARVJETYAPO9SUWZQHAKJAUWBIWQDSQ9FWIEWSJWKQGNIFGGVKZLWZZOVVBGPNRTONMZDLJHGWQUSCILYOBG9YUUUZDXILKBIQ9ZEKXEHURJLFMDB9CUZI9TEJSQZYHMNTX9F9GJBZ9UJNCKZVYAROOVZYZURRWKLYHJEMZDQLH9FWODFZUEZRV9DWNZCOMXNXFWCPCZQDGFP9DKJYUNXIYIRUVWRSWWIGKZWITSYIVEOPHBJGSZNYJSFTXAKLENHCPGOYQSGEZQMRVNFGAGZXFG9GYFIBJRVU9MYDSZSTJQVVODQJJEHYJYCHOHTCOPZJVGMBEIIGYFMNAPZATAHQGFVWSGYODTOHRE9FVYXSLESASDMMAPBZZVPLIWGIRORAGWNFA9JPSUWJCTNBYRDJANSYMNDGQJNSFQRSVMRIAXDWQONWSAYUYFXJUTWYLPXVV9YGJBMQUXODSEFAEGYXSYYEQTVRAWNCKKSWPRYYINMBOBNZJSANFLKDFMGTNUDU9SFQRBUJM9XDNWIECTJPEICLVXTMCMGQJT9BTRZ9HQCHHBYXSPJBGTSTJDIOUQ9SLRVHTENSCLLGBFMXOYFKYB9SAKWTPGHEXPU9ERFYGEMEPSLJUPRJNRRWQLA9XVSWBEGJHLLDXGDTESDPRBRQHLCIOPWBDYJVCLOHHDYFNQSXBOVUVICSVBMEZYJJZHGDKAHFRJHBDWUSFSGC9UCLVH9ZNVMPYMRMMJTSWAFDRGNALYLRRVPLGMMKGZR9LXEV9ZXRPFKYDBLIUEVEJKVDANOBKFLRSWQPMOMTEJA9WVHFGBNTAJIPWNUWKJMQAOKBCACLYGRCBZRVFKIOMCXYXGUTNODHMLOZRETEPDONTAPVQEQAWCAH9CSTPYRFUXPKBDVONWFNOZHA9N9YUTEIGAHAPEKNWGCXNAMVJVLPCAPDPNTVVSKROYWXDKVLOAHPCCJBGBPSMQEDFDXSGNMIMLEZPBVCKYKVZFFIZVECYQKQWDHXRVEAOL9QIDZK9JFBRYL9JOSAWMBZAXJWNBTLKRSIYHZEILOPRZVLOFACJGIPABPFZILVQMUAYMPABXEBDYOSYBZKUXCFVXUEQJJOUDMBZZGOBVBF9N9ENHSCTDVFASKXHOLLFYMMWSDFHJKHODXYPWMEOQZKIECIBHYXF9PXZOCBMIBI9PLVDVBGALAWBT9FLIZWRNENVLSUCSOATNVRUKTTWZNTZRCMTLALKYGOUKVSO9BBUDVUCFCIKQZWJIUBMXTSNQSFRETWAHPQ9MTYOUKX9BLA9QUUHPNLNINNIPWQVUPUCXHTMURNWYSUGOKWPYMZ9ILDJWEOD9D99YWKQTKKOOWQOLEZMTZ99AYQPWUVVZUNVORK9XRAE9GQSHLVIZLCEDWHSWYNVZKELOI9AVGUWFSJYHA9WZNVNZYFEZYJAXKUOPINHR9OEN9NVLNIDEJLPLVEMIANSGFXXXL9IKQAFLFPOPWO9SAEMNETZMUM9NEHAA9JOGLHOBHYHXASFWHGNKCRNWZSCDPIFGFHOFLWCOMNCPRBECDEVSNXGKNF9IOYIVZRBJJHCREKOFHMTXXALIWOGOZRIJITCWGKQKCVUPUOFNMEUGSVPYAKRORXQHUXJVCAEWJBLAPDDSCIYMODOMM9GWQSVQUBGBUUDVGSSHAONRHVMILHPMBHKKHUTRZFWNAEEUHCQUGHLSVXAMOGVTXELPGKXBHELPCGYRCLMYGIZYLANN9LSXCQVQPBLIZXJUVRTA9CQAFSWWTIBILERJDTYHJWDPOYHNCHJEWSVXEJCPZVNVLWWOAZHJLLTS9WAEXXSMWHITJYJLFHGGDFNYIGDKJFUZGSJDCXSVNZQYUSAPVJRHSRNLNQDLDBEFPLRXJ9MIZBPNBZVHHLOYC9VYLDKNJAHLNPRCSOZKHWHQKXYWXABCPHYNQYRZJEARZCOLQMBCJCHNNSFGORUOHFOFJMF9MJHHFFVBCS9QITDPGXTJKDDJKHGBOLEVMXRAWUMCXUABILEYVHRTZFFMAM9REMUPNEPUHKWFHOJEFBLXXYHI99UDFMXLXEFWQLPTKJJQEQAXYCQNCZMMOTSKGQCJNFCWGUISHWZLDWJBNNAFDDOMOJ9QRVDEXXNHLKVP9CQJSGZRT9CHDTUJIXWM9WB9RTYQ9EEIJWEVSGKQPFLKG9HKNWSGWZUAGOBENKKT9NUMUIAPWZ9UESGRDITJSOMJAPHIN9CJSSUJCAKCLTQPJOUEMKVLSZZ9MAEROPNSBHPHOFBVVOSNTWPSCRTAYQJQSG9YXPRMAHREBCQKMRFISYDXXNRMGEHCXFNH9SAGFOYAHFCQRNQFRXDIJAIBIRPBNVQZLZNJHBVCZHOIHJURHCFFVHFCPBSKGLQOCXKWXSFINGLYQAH9YGPFWJGQDOUIMFJJOFGNDREMEIMDKOEQONGHTVYWVXWHQQOJGCM9YEHBCVWNJLJXK9HQB9BDYTUJVTHYU9R9DPMUHTLB9NGFEEVKIUANTFHUQRRK9LSSFMUBZLKJTJLPQLBEUSVAFJURBSGFNMBZCDKEUTCNYHBZPUCZGQDAP9JISCORGZVTMLCFRDHKJBCEOYOHEHUDTHMGHMFDTPKGNQPCIBTSOCISWKFSMPDVUKPAWVACALATUSWJTJPXHJWUFDEICUNUDSHGYEGRPMDRABLMFCHXNUA9LHNUMDKXH99XGJKU9XMUXFOXKWLI9AFNDD9CSETSFB9MLEMEY9UMHQQYROBZZEBGHRQRERMHILEVEGNOBSFUIIIJZHRFPOBXHGRSXPYEC\");\n\nbundle = new Int8Array(fs.readFileSync('bundle'));\n\n// Transaction 0 is the output transaction, so start adding the signature fragments, starting from the next transaction in the bundle\nbundle.set(Bundle.addSignatureOrMessage(bundle, signature, 1));\n\nconst trytes = []\nfor (let offset = 0; offset < bundle.length; offset += Transaction.TRANSACTION_LENGTH) {\n  trytes.push(Converter.tritsToTrytes(bundle.subarray(offset, offset + Transaction.TRANSACTION_LENGTH)));\n}\n\nconst iota = Iota.composeAPI({\n  // Replace with the URL of the IRI node you want to send the transactions to\n  provider: 'https://pow.iota.community:443'\n});\n\nconst depth = 3;\nconst minWeightMagnitude = 14;\n\n// We need the bundle to be in order head to tail before sending it to the node\niota.sendTrytes(trytes.reverse(), depth, minWeightMagnitude)\n  .then(bundle => {\n    console.log(`Sent bundle: ${JSON.stringify(bundle, null, 1)}`)\n  })\n  .catch(error => {\n    console.log(error);\n  });\n```\n","title":"スウィープしたアドレスからトークンを救う | ハウツーガイド | ハブ | ウォレット"}}
