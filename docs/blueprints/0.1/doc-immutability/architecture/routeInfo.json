{"path":"docs/blueprints/0.1/doc-immutability/architecture","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# Application architecture\n\n**The Document immutability application consists of two parts: A graphical user interface (GUI), written in React and a back-end API, written in NodeJS.**\n\n:::warning:Disclaimer\nRunning an open source project, like any human endeavor, involves uncertainty and trade-offs. We hope the architecture described below helps you to deploy similar systems, but it may include mistakes, and can’t address every situation. If you have any questions about your project, we encourage you to do your own research, seek out experts, and discuss them with the IOTA community.\n:::\n\n## Instructions and technical concepts\n\nThis projects assumes some level of programming knowledge.\n\n- [PoC source code](https://github.com/iotaledger/poc-document-immutable-blueprint)\n- [Proof of existence library](https://www.npmjs.com/package/@iota/poex-tool)\n\nHere is an illustration of the system components:\n\n![Document immutability architecture](/assets/docs/blueprints/0.1/images/document-immutability-architecture.png)\n\n### File storage\n\nA database for storing documents, it can be either maintained by the user or a third party provided as a service like (Google drive, D2ropbox etc..), usually for scalability and faster development reasons, better to have it as a service.\n\n### Database\n\nThis can be a commonly used DB like MariaDB, postgreSQL etc. \nThe main role is to persist references/link to the stored file. Without these references the stored files are lost forever (in case of a lost link to the actual data).\n\n### IOTA Application \n\nThis is where our application logic resides, it contains an app that is responsible for interacting with all application components. For example, Generating Hash and Document ID, storing the document in the file storage, persisting data in the Database using postgreSql then publishing it to the Tangle.\nThe application layer is also the one responsible for checking the document immutability.\n\n### The Tangle\n\nThe Tangle is the technology enabler for IOTA ecosystem, in this PoC scope, we are going to use it as a source of truth to hold and expose all the document signatures to check their immutability.\nIn order to use the Tangle you have to connect an IRI node, from there your data is spread and duplicated into other nodes.\n\n## Prerequisites\n\n- Hardware\n    - Any processor able to run this app smoothly, included mobile phones.\n- Software \n    - Node.js 8+\n    - Any supported Browser (Chrome, Firefox)\n    - IOTA.js\n    - Storage service like Google Drive or Dropbox\n    - Database (either locally postgres or online like Firebase)\n- Programming language(s) used:\n    - Javascript\n    - HTML/CSS\n- Required 3rd party licenses\n    - Apache 2.0, MIT, usually inherited by our libraries IOTA.JS\n- IOTA knowledge\n  - Intermediate Javascript knowledge \n  - Understanding how to send Transaction with Metadata using IOTA.JS\n- Partner knowledge\n  - Sending 0 value Transactions.\n  - How to use databases (optional)\n  - How to use Google drive APIs (optional)\n\n### Deployment\n\nThere is no restriction on the manner of deployment, you can run this completely using online services (e.g. Google drive and Firebase) or completely on your own server - depending on your needs you might choose one or another.\n\n:::warning:Disclaimer\nRunning an open source project, like any human endeavor, involves uncertainty and trade-offs. We hope the architecture described below helps you to deploy similar systems, but it may include mistakes, and can’t address every situation. If you have any questions about your project, we encourage you to do your own research, seek out experts, and discuss them with the IOTA community.\n:::\n\n## Generic Diagram (Document hashing)\n\nUsually when it comes to document storage a common pattern is to use an external storage service, as this comes with a lot of benefits such as simpler indexing, easy scalability and faster development.\n\nThese external document stores can be hosted by you or provided as a service (e.g. Google drive, dropbox etc)\n\nThis figure shows the case of document signing and how the interaction between the external document storage and the rest of the system is done.\n\n![Document hashing](/assets/docs/blueprints/0.1/images/document-immutability-hashing.png)\n\n### 1 - Document hashing\n\nDocument hashing is a crucial step where we generate document Hash, this Hash will be used in the persistence metadata step.\n\n### 2 - Storage\n\nWe store the document in one of the chosen services and make sure we got a URL for it to get the document back again later when doing verification.\n\n### 3 - Get Document ID\n\nUsually when using an external file storage, after the upload we get a Document ID where we can save somewhere else to retrieve the file later.\n\n### 4 - Publish the Hash to the Tangle\n\nPublish the hash of the document in the Tangle in a Transaction metadata, this will ensure that the saved hash is not compromised nor changed overtime.\n\n### 5 - Persist document Metadata in the Database\n\nAfter the sending of new Transaction, we get a TX HASH then we Persist the generated Document ID (the URL) along with the TX HASH into the Database, we can also put more metadata along with it such as Date/time, size etc.\nThis will not have any benefits for the scope of this PoC, probably will be more useful when more requirements are needed.\n\n## Generic Diagram (Document verification)\n\nIn a similar manner to the Document hashing step, Document verification is composed with the exact system components, the only difference is that the steps execution.\n\n![Document verification](/assets/docs/blueprints/0.1/images/document-immutability-verification.png)\n\n### 1 - Get ID/ROOT(TX Hash)\n\nThe first step would be that we query the saved metadata of the signed document, it contains essentially the TX Hash and the document ID, the response return should at least contain these properties:\n\nThe first step would be that we query the saved metadata of the signed document, it contains essentially the TX Hash and the document ID, the response return should at least contain these properties:\n\n```json\n{\n    Url: http://my_document.pdf,\n    txHash: AD9FE...YA99F9\n}\n```\n\n### 2 - Download the Document\n\nFrom the previous queried URL we download the file from the document storage\n\n### 3 - Fetch from Tangle\n\nThen we fetch the Hash from the Tangle, the response will be something similar to this:\n\n```json\n{\n    Hash: ac5e...f1f8\n}\n```\n\nThis is can be considered as minimal data can be stored in the tangle, but it's up to the user to store even more data if needed.\n\n### 4 - Calculate the hash again\nOnce the document is downloaded we calculate the hash of it using the exact same way we did it the first time (using the same hashing algorithm) to ensure deterministic results.\nLet’s suppose that our document hasn’t changed since our first storage, using the same hash method should produce the same hash:\n\n```json\n    Hash = ac5e...f1f8\n```\n\n### 5 - Compare hashes\n\nSince the both hashes (the one fetched from Tangle and the calculated one) matches we can safely stamp the document as valid.\n\n## Hashing algorithms\n\nAt the time of writing we highly recommend using at least 128 bits hashing algorithm.\n\n:::warning:Disclaimer\nIt is recommended to use 128 bits hashing algorithm ( eg: SHA256 ), hashing algorithm like MD5 or SHA1 are vulnerable to attack as they are proven in practice that can be hijacked.\n:::\n\n\n- SHA256 - 2<sup>128</sup>\n- SHA512 - 2<sup>256</sup>\n- SHA-3\t- Up to 2<sup>512</sup>\n- BLAKE2s - 2<sup>128</sup>\n- BLAKE2b - 2<sup>256</sup>\n\nRead more [here](https://en.wikipedia.org/wiki/Hash_function_security_summary)\n\n## Sequence Diagram\n\nIn this section we are going to describe some scenarios that can happen when using the PoC, there are mainly two main scenarios described below.\n\n\n### Signing the document Scenario \n\nIn this scenario we cover the case where the user or whom is responsible for uploading the document the very first time wants to protect the document against mutability. \n\n1.\tHashing the document\n2.\tUploading the document\n3.\tRetrieving a URL after upload is complete\n4.\tPublish to the tangle the calculated hash\n5.\tPersisting the Generated Root (TX Hash) and URL.\n\n\n![Document hashing](/assets/docs/blueprints/0.1/images/document-immutability-signing.png)\n\n### Verifying document Scenario \n\nThis is the second case when anyone is concerned about checking the document signature, the following diagram will explain how the document is being verified.\n\n1.\tQuery the database for the document metadata (URL/ROOT(TX Hash) in this case)\n2.\tDownload the original file using the queried URL\n3.\tFetch the saved hash in the tangle \n4.\tCalculate the document hash again\n5.\tCompare the saved hash with the newly calculated one.\n\n![Document hashing](/assets/docs/blueprints/0.1/images/document-immutability-verification2.png)\n\n\n","title":"App architecture | Document immutability | アプリの青写真"}}
