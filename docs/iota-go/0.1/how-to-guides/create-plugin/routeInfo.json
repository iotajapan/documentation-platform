{"path":"docs/iota-go/0.1/how-to-guides/create-plugin","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# プラグインを作成する\n<!-- # Create a plugin -->\n\n**プラグインはアカウントの機能を拡張します。すべてのプラグインは独自のゴルーチンで実行され、アカウントとともに起動およびシャットダウンされます。**\n<!-- **Plugins extend the functionality of an account. All plugins run in their own goroutine and start and shut down together with an account.** -->\n\n## 前提条件\n<!-- ## Prerequisites -->\n\n[新しいアカウントを作成](../how-to-guides/create-account.md)します。\n<!-- [Create a new account](../how-to-guides/create-account.md). -->\n\nこのガイドは[概要の「はじめに」](../README.md)で紹介されている、プロジェクトの依存関係を管理するための[Goモジュール](https://github.com/golang/go/wiki/Modules)を使っていると仮定します。\n<!-- This guide assumes that you've followed our [Getting started guide](../README.md) and are using the [Go modules](https://github.com/golang/go/wiki/Modules) to manage dependencies in your project. -->\n\n## スクリーンにイベントを出力するプラグインを作成する\n<!-- ## Create a plugin that prints events to the screen -->\n\nこのガイドでは、プラグインの作成方法を説明するために、イベントが発生したときにイベントをスクリーンに出力するプラグインを作成します。\n<!-- To explain how to create a plugin, this guide helps you to create one that prints events to the screen as they happen. -->\n\n:::info:\n利用可能性なすべてのチャネルイベントの一覧は[こちら](https://github.com/iotaledger/iota.go/blob/master/account/event/listener/channel_listener.go)をご参照ください。\n:::\n<!-- :::info: -->\n<!-- See the list of all possible [channel events](https://github.com/iotaledger/iota.go/blob/master/account/event/listener/channel_listener.go). -->\n<!-- ::: -->\n\n1. `event_logger.go`という新しいファイルを作成します。\n  <!-- 1. Create a new file called `event_logger.go` -->\n\n2. 必要なパッケージをインポートします。\n  <!-- 2. Import the required packages -->\n\n    ```go\n    package main\n\n    import (\n    \t\"fmt\"\n\n    \t\"github.com/iotaledger/iota.go/account\"\n    \t\"github.com/iotaledger/iota.go/account/event\"\n    \t\"github.com/iotaledger/iota.go/account/event/listener\"\n    )\n    ```\n\n3. `EventMachine`オブジェクトを引数として受け取り、`account.Plugin`オブジェクトを返す関数を作成します。\n  <!-- 3. Create a function that takes an `EventMachine` object as an argument and returns an `account.Plugin` object -->\n\n    ```go\n    // NewEventLoggerPlugin ...\n    func NewEventLoggerPlugin(em event.EventMachine) account.Plugin {\n    \treturn &logplugin{em: em, exit: make(chan struct{})}\n    }\n\n    type logplugin struct {\n    \tem   event.EventMachine\n    \tacc  account.Account\n    \texit chan struct{}\n    }\n    ```\n\n4. プラグインの名前を返す`Name()`関数を作成します。\n  <!-- 4. Create a `Name()` function that returns the name of the plugin -->\n\n    ```go\n    func (l *logplugin) Name() string {\n    \treturn \"eventLogger\"\n    }\n    ```\n\n    :::info:\n    `account`オブジェクトは、デバッグに役立つようにエラーメッセージでこの名前を使用します。\n    :::\n    <!-- :::info: -->\n    <!-- The `account` object uses this name in error messages to help you debug. -->\n    <!-- ::: -->\n\n5. アカウントの開始時に呼び出される`Start()`関数を作成します。アカウントが開始されると、すべてのプラグインは`account`オブジェクトを引数として取ります。\n  <!-- 5. Create a `Start()` function that will be called when the account starts. When an account is started, all plugins take the `account` object as an argument. -->\n\n    ```go\n    func (l *logplugin) Start(acc account.Account) error {\n    \tl.acc = acc\n    \tl.log()\n    \treturn nil\n    }\n    ```\n\n6. アカウントと同時にプラグインをシャットダウンする`Shutdown()`関数を作成します。\n  <!-- 6. Create a `Shutdown()` function that shuts down the plugin at the same time as the account -->\n\n    ```go\n    func (l *logplugin) Shutdown() error {\n    \tl.exit <- struct{}{}\n    \treturn nil\n    }\n    ```\n\n7. イベント発生時にすべてのイベントをスクリーンに出力する`log()`関数を作成します。\n  <!-- 7. Create the `log()` function that will print all events to the screen when they happen -->\n\n    ```go\n    func (l *logplugin) log() {\n    \tlis := listener.NewChannelEventListener(l.em).All()\n\n    \tgo func() {\n    \t\tdefer lis.Close()\n    \t\texit:\n    \t\tfor {\n    \t\t\tselect {\n    \t\t\tcase ev := <-lis.Promoted:\n    \t\t\t\tfmt.Printf(\"Promoted %s with %s\\n\", ev.BundleHash[:10], ev.PromotionTailTxHash)\n    \t\t\tcase ev := <-lis.Reattached:\n    \t\t\t\tfmt.Printf(\"Reattached %s with %s\\n\", ev.BundleHash[:10], ev.ReattachmentTailTxHash)\n    \t\t\tcase ev := <-lis.SentTransfer:\n    \t\t\t\ttail := ev[0]\n    \t\t\t\tfmt.Printf(\"Sent %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n    \t\t\tcase ev := <-lis.TransferConfirmed:\n    \t\t\t\ttail := ev[0]\n    \t\t\t\tfmt.Printf(\"Transfer confirmed %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n    \t\t\tcase ev := <-lis.ReceivingDeposit:\n    \t\t\t\ttail := ev[0]\n    \t\t\t\tfmt.Printf(\"Receiving deposit %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n    \t\t\tcase ev := <-lis.ReceivedDeposit:\n    \t\t\t\ttail := ev[0]\n    \t\t\t\tfmt.Printf(\"Received deposit %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n    \t\t\tcase ev := <-lis.ReceivedMessage:\n    \t\t\t\ttail := ev[0]\n    \t\t\t\tfmt.Printf(\"Received msg %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n    \t\t\tcase balanceCheck := <-lis.ExecutingInputSelection:\n    \t\t\t\tfmt.Printf(\"Doing input selection (balance check: %v) \\n\", balanceCheck)\n    \t\t\tcase <-lis.PreparingTransfers:\n    \t\t\t\tfmt.Printf(\"Preparing transfers\\n\")\n    \t\t\tcase <-lis.GettingTransactionsToApprove:\n    \t\t\t\tfmt.Printf(\"Getting transactions to approve\\n\")\n    \t\t\tcase <-lis.AttachingToTangle:\n    \t\t\t\tfmt.Printf(\"Doing proof of work\\n\")\n    \t\t\tcase err := <-lis.InternalError:\n    \t\t\t\tfmt.Printf(\"Received internal error: %s\\n\", err.Error())\n    \t\t\tcase <-l.exit:\n    \t\t\t\tbreak exit\n    \t\t\t}\n    \t\t}\n    \t}()\n    }\n    ```\n\n8. ファイルを保存します。\n  <!-- 8. Save the file -->\n\n9. `myAccount.go`という新しいファイルを作成します。\n  <!-- 9. Create a new file called `myAccount.go` -->\n\n10. `NewEventLoggerPlugin()`関数を使用してアカウントを作成します。\n  <!-- 10. Build your account with the `NewEventLoggerPlugin()` function -->\n\n    ```go\n    account, err = builder.NewBuilder().\n    \t// Load the IOTA API to use\n    \tWithAPI(iotaAPI).\n    \t// Load the database onject to use\n    \tWithStore(store).\n    \t// Load the seed of the account\n    \tWithSeed(seed).\n    \t// Use the minimum weight magnitude for the Devnet\n    \tWithMWM(9).\n    \t// Load the time source to use during input selection\n    \tWithTimeSource(timesource).\n    \t// Load the EventMachine\n    \t.WithEvents(em)\n    \t// Load the default plugins that enhance the functionality of the account\n    \tWithDefaultPlugins().\n    \t// Load your custom plugin\n    \tBuild( NewEventLoggerPlugin(em) )\n    handleErr(err)\n    ```\n\n:::success:おめでとうございます！:tada:\n最初のプラグインを作成しました。\n\n今、アカウントが開始されると、イベントをリッスンするために何もする必要はありません。プラグインはイベントが起こるたびにコンソールにすべてのイベントを出力します。\n:::\n<!-- :::success:Congratulations! :tada: -->\n<!-- You've just created your first plugin. -->\n<!--  -->\n<!-- Now, when your account starts, you don't have to do anything to listen to events. Your plugin will print all events to the console as they happen. -->\n<!-- ::: -->\n","title":"カスタムプラグインを作成する | ハウツーガイド | Goライブラリ"}}
