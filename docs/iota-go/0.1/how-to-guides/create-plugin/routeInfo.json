{"path":"docs/iota-go/0.1/how-to-guides/create-plugin","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# Create a plugin\n\n**Plugins extend the functionality of an account. All plugins run in their own goroutine and start and shut down together with an account.**\n\n## Prerequisites\n\n[Create a new account](../how-to-guides/create-account.md).\n\nThis guide assumes that you've followed our [Getting started guide](../README.md) and are using the [Go modules](https://github.com/golang/go/wiki/Modules) to manage dependencies in your project.\n\n## Create a plugin that prints events to the screen\n\nTo explain how to create a plugin, this guide helps you to create one that prints events to the screen as they happen.\n\n:::info:\nSee the list of all possible [channel events](https://github.com/iotaledger/iota.go/blob/master/account/event/listener/channel_listener.go).\n:::\n\n1. Create a new file called `event_logger.go`\n\n2. Import the required packages\n\n    ```go\n    package main\n\n    import (\n        \"fmt\"\n\n        \"github.com/iotaledger/iota.go/account\"\n        \"github.com/iotaledger/iota.go/account/event\"\n        \"github.com/iotaledger/iota.go/account/event/listener\"\n    )\n    ```\n\n3. Create a function that takes an `EventMachine` object as an argument and returns an `account.Plugin` object\n\n    ```go\n    // NewEventLoggerPlugin ...\n    func NewEventLoggerPlugin(em event.EventMachine) account.Plugin {\n        return &logplugin{em: em, exit: make(chan struct{})}\n    }\n\n    type logplugin struct {\n        em   event.EventMachine\n        acc  account.Account\n        exit chan struct{}\n    }\n    ```\n\n4. Create a `Name()` function that returns the name of the plugin\n\n    ```go\n    func (l *logplugin) Name() string {\n\treturn \"eventLogger\"\n    }  \n    ```\n\n    :::info:\n    The `account` object uses this name in error messages to help you debug.\n    :::\n\n5. Create a `Start()` function that will be called when the account starts. When an account is started, all plugins take the `account` object as an argument.\n\n    ```go\n    func (l *logplugin) Start(acc account.Account) error {\n\tl.acc = acc\n\tl.log()\n\treturn nil\n    }\n    ```\n\n6. Create a `Shutdown()` function that shuts down the plugin at the same time as the account\n\n    ```go\n    func (l *logplugin) Shutdown() error {\n        l.exit <- struct{}{}\n        return nil\n    }\n    ```\n\n7. Create the `log()` function that will print all events to the screen when they happen\n\n    ```go\n    func (l *logplugin) log() {\n\tlis := listener.NewChannelEventListener(l.em).All()\n\n\tgo func() {\n\t\tdefer lis.Close()\n\t    exit:\n            for {\n                select {\n                case ev := <-lis.Promoted:\n                    fmt.Printf(\"Promoted %s with %s\\n\", ev.BundleHash[:10], ev.PromotionTailTxHash)\n                case ev := <-lis.Reattached:\n                    fmt.Printf(\"Reattached %s with %s\\n\", ev.BundleHash[:10], ev.ReattachmentTailTxHash)\n                case ev := <-lis.SentTransfer:\n                    tail := ev[0]\n                    fmt.Printf(\"Sent %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n                case ev := <-lis.TransferConfirmed:\n                    tail := ev[0]\n                    fmt.Printf(\"Transfer confirmed %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n                case ev := <-lis.ReceivingDeposit:\n                    tail := ev[0]\n                    fmt.Printf(\"Receiving deposit %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n                case ev := <-lis.ReceivedDeposit:\n                    tail := ev[0]\n                    fmt.Printf(\"Received deposit %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n                case ev := <-lis.ReceivedMessage:\n                    tail := ev[0]\n                    fmt.Printf(\"Received msg %s with tail %s\\n\", tail.Bundle[:10], tail.Hash)\n                case balanceCheck := <-lis.ExecutingInputSelection:\n                    fmt.Printf(\"Doing input selection (balance check: %v) \\n\", balanceCheck)\n                case <-lis.PreparingTransfers:\n                    fmt.Printf(\"Preparing transfers\\n\")\n                case <-lis.GettingTransactionsToApprove:\n                    fmt.Printf(\"Getting transactions to approve\\n\")\n                case <-lis.AttachingToTangle:\n                    fmt.Printf(\"Doing proof of work\\n\")\n                case err := <-lis.InternalError:\n                    fmt.Printf(\"Received internal error: %s\\n\", err.Error())\n                case <-l.exit:\n                    break exit\n                }\n            }\n        }()\n    }\n    ```\n\n8. Save the file\n\n9. Create a new file called `myAccount.go`\n\n10. Build your account with the `NewEventLoggerPlugin()` function\n\n    ```go\n    account, err = builder.NewBuilder().\n        // Load the IOTA API to use\n        WithAPI(iotaAPI).\n        // Load the database onject to use\n        WithStore(store).\n        // Load the seed of the account\n        WithSeed(seed).\n        // Use the minimum weight magnitude for the Devnet\n        WithMWM(9).\n        // Load the time source to use during input selection\n        WithTimeSource(timesource).\n        // Load the EventMachine\n        .WithEvents(em)\n        // Load the default plugins that enhance the functionality of the account\n        WithDefaultPlugins().\n        // Load your custom plugin\n\t\tBuild( NewEventLoggerPlugin(em) )\n    handleErr(err)\n    ```\n\n:::success:Congratulations! :tada:\nYou've just created your first plugin.\n\nNow, when your account starts, you don't have to do anything to listen to events. Your plugin will print all events to the console as they happen.\n:::\n","title":"カスタムプラグインを作成する | ハウツーガイド | Goライブラリ"}}
