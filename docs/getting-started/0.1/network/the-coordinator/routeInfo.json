{"path":"docs/getting-started/0.1/network/the-coordinator","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# コーディネーター\n<!-- # The Coordinator -->\n\n**コーディネーターは、IOTA 財団によって実行されるアプリケーションであり、その目的は[タングル](../network/the-tangle.md)を[パラサイトチェーン](https://blog.iota.org/attack-analysis-the-simple-parasite-chain-42a34bfeaf23)などの攻撃から保護することです。[ノード](../network/nodes.md)は、コーディネーターを使用して、トランザクションが確定されるコンセンサスに到達します。**\n<!-- **The Coordinator is an application that's run by the IOTA Foundation and whose purpose is protect the [Tangle](../network/the-tangle.md) from attacks such as [parasite chains](https://blog.iota.org/attack-analysis-the-simple-parasite-chain-42a34bfeaf23). [Nodes](../network/nodes.md) use the Coordinator to reach a consensus on which transactions are confirmed.** -->\n\n## マイルストーン\n<!-- ## Milestones -->\n\n同じ [IOTA ネットワーク](../network/iota-networks.md)内のすべてのノードは、コーディネーターの[アドレス](../clients/addresses.md)でハードコーディングされています。\n<!-- All nodes in the same [IOTA network](../network/iota-networks.md) are hard-coded with the [address](../clients/addresses.md) of a Coordinator. -->\n\nコーディネーターは、コーディネーターのアドレスを所有していることをノード群に証明するために、マイルストーンと呼ばれるトランザクションの[バンドル](../transactions/bundles.md)を定期的に作成、署名、送信します。\n<!-- To prove to nodes that it owns the address, the Coordinator creates, signs, and sends [bundles](../transactions/bundles.md) of transactions called milestones at regular intervals. -->\n\nこのバンドルには次のものが含まれています。\n<!-- These bundles contain the following: -->\n\n- 分断化された署名を含めるのに十分なゼロトークントランザクション\n<!-- - Enough zero-value transactions to contain the fragmented signature -->\n- ノードが欠損データを再構築できるように、マークル木からの十分な欠損データが[`signatureMessageFragment` フィールド]に含まれている1つのトランザクション\n<!-- - One transaction whose [`signatureMessageFragment` field](../transactions/transactions.md#signatureMessageFragment) contains enough missing data from the Merkle tree to allow the node to rebuild it -->\n\n有効なマイルストーンのトランザクションがタングル上の既存のトランザクションを参照する場合、ノード群はその既存のトランザクションのステートとその履歴全体を確定済みとしてマークします。\n<!-- When a transaction in a valid milestone references an existing transaction in the Tangle, nodes mark the state of that existing transaction and its entire history as confirmed. -->\n\n![Milestones being attached to the Tangle](/assets/docs/getting-started/0.1/images/milestones.gif)\n\n## コーディネーターのマークル木\n<!-- ## The Coordinator's Merkle tree -->\n\n[署名](../clients/signatures.md)はアドレスの所有権を証明し、かつ IOTA はワンタイム署名を使用しているため、コーディネーターは毎回同じ秘密鍵でバンドルに署名することなく、多数のアドレスを所有していることをノードに証明する必要が有ります。\n<!-- Because [signatures](../clients/signatures.md) prove ownership of an address and IOTA uses one-time signatures, the Coordinator needs a way to prove to nodes that it owns an address without signing bundles with the same private key every time. -->\n\nそのために、コーディネーターのアドレスは[マークル木](https://en.wikipedia.org/wiki/Merkle_tree)から導出されます。アドレスはマークル木のルートであり、秘密鍵はマークル木のリーフです。\n<!-- To do so, the Coordinator's address is derived from a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree), where the address is the root, and the private keys are the leaves. -->\n\n## マークル木の生成方法\n<!-- ## How the Merkle tree is generated -->\n\nマークル木を生成するには、まず、コーディネーターのシードから多数のアドレスと秘密鍵を生成します。\n<!-- To generate the Merkle tree, first a number of addresses and private keys are generated from the Coordinator's seed. -->\n\n生成されるアドレスの総数は、次の式のマークル木の深さ (depth) に依存します。\n<!-- The total number of addresses that are generated depends on the depth of the Merkle tree in this formula: -->\n\n2<sup>depth</sup>\n\n### マークル木の例\n<!-- ### Example Merkle tree -->\n\nこの例では、4つのリーフがあり、それぞれがアドレスを表すため、マークル木の深さは2です。\n<!-- In this example, the Merkle tree's depth is 2 because we have 4 leaves, which each represent an address. -->\n\n![Example Merkle tree](/assets/docs/getting-started/0.1/images/merkle-tree-example.png)\n\n:::info:\nメインネットでは、コーディネーターのマークル木の深さは23です。したがって、コーディネーターは8,388,608個の秘密鍵を持ち、各鍵を使用してバンドルに署名できます。\n:::\n<!-- :::info: -->\n<!-- On the Mainnet, the Coordinator's Merkle tree has a depth of 23. So, the Coordinator has 8,388,608 private keys and can use each one to sign a bundle. -->\n<!-- ::: -->\n\nコーディネーターのアドレスを生成するために、リーフはペアでハッシュされます。\n<!-- To generate the Coordinator's address, the leaves are hashed in pairs: -->\n\n- **ノード 1:** Hash(Hash(リーフ 1) Hash(リーフ 2))\n- **ノード 1:** Hash(Hash(リーフ 1) Hash(リーフ 2))\n- **ノード 2:** Hash(Hash(リーフ 3) Hash(リーフ 4))\n- **コーディネーターのアドレス:** Hash(Hash(ノード 1) Hash(ノード 2))\n\nノード1は、リーフ1とリーフ2のハッシュ結果のハッシュ値です。ノード2は、リーフ3とリーフ4のハッシュ結果のハッシュ値です。コーディネーターのアドレスは、ノード1のハッシュ値とノード2のハッシュ値のハッシュ結果のハッシュ値です。\n<!-- Node 1 is a hash of the result of hashing leaf 1 and leaf 2. Node 2 is a hash of the result of hashing leaf 3 and leaf 4. The Coordinator's address is a hash of the result of hashing the hash of node 1 and node 2. -->\n\n## ノードによるマイルストーンの検証方法\n<!-- ## How nodes validate milestones -->\n\nノードは、コーディネーターのアドレスから送信されたトランザクションを見ると、次のことを実行してコーディネーターのアドレスから送信されたトランザクションを検証します。\n<!-- When nodes see a transaction that's been sent from the Coordinator's address, they validate it by doing the following: -->\n\n- トランザクションが二重支払いにつながらないことを確認する\n<!-- - Make sure that it doesn't lead to a double-spend -->\n- トランザクションの署名を検証する\n<!-- - Verify its signature -->\n\n![Example Merkle tree](/assets/docs/getting-started/0.1/images/merkle-tree-example.png)\n\n署名を検証するために、ノードはマイルストーンの情報を使用してマークル木を再構築し、マークルルートを見つけます。再構築されたマークルルートがコーディネーターのアドレスと同じ場合、ノードはマイルストーンがコーディネーターによって送信されたことを認識します。\n<!-- To verify the signature, nodes use the information in the milestones to rebuild the Merkle tree and find the Merkle root. If the rebuilt Merkle root is the same as the Coordinator's address, nodes know the milestone was sent by the Coordinator. -->\n\n### マイルストーン検証の例\n<!-- ### Example milestone validation -->\n\nたとえば、ノードとして、リーフ1の秘密鍵で署名されたバンドルを見たとします。\n<!-- For example, as a node, we have seen a bundle that was signed with the private key of leaf 1. -->\n\n最初に、リーフ1のアドレスを見つけるために[署名を検証](../clients/signatures.md#how-nodes-validate-signatures)します。\n<!-- First, we [validate the signature](../clients/signatures.md#how-nodes-validate-signatures) to find out the address in leaf 1. -->\n\nマークルルートを計算しやすくするために、バンドルのマイルストーンの1つトランザクションに次のものが含まれています。\n<!-- To help us calculate the Merkle root, one of the milestones in the bundle contains the following: -->\n\n- リーフ2のアドレス\n<!-- - The address in leaf 2 -->\n- ノード2のハッシュ値\n<!-- - The hash in node 2 -->\n\n次に、リーフ1のアドレスとリーフ2のアドレスをハッシュしてノード1のハッシュ値を見つけます。次に、ノード1のハッシュ値とノード2のハッシュ値をハッシュしてマークルルートを見つけます。\n<!-- Now, we hash the addresses in leaves 1 and 2 to find the hash in node 1. Then, we hash the hash in nodes 1 and 2 to find the Merkle root. -->\n\nこの導き出したマークルルートがコーディネーターのアドレスと同じである場合、バンドルはコーディネーターのマークル木の秘密鍵のいずれかで署名されています。\n<!-- If the Merkle root is the same as the Coordinator's address, the bundle was signed with one of the private keys in the Coordinator's Merkle tree. -->\n\n## コーディサイド\n<!-- ## Coordicide -->\n\nIOTA 財団の研究部門は、コーディネーターの削除の提案である[コーディサイド](https://coordicide.iota.org/)と呼ばれるプロジェクトに焦点を当てています。コーディサイドが発生すると、ノードはマイルストーンなしで合意に達することができます。\n<!-- The Research Department at the IOTA Foundation is focused on a project called [Coordicide](https://coordicide.iota.org/), which is a proposal for the removal of the Coordinator. When this happens, nodes will be able to reach a consensus without milestones. -->\n","title":"コーディネーター | ネットワーク | IOTA入門"}}
