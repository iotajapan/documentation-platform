{"path":"docs/dev-essentials/0.1/concepts/the-tangle","templateID":1,"sharedPropsHashes":{},"localProps":{"markdown":"# タングル\n<!-- # The Tangle -->\n\n**タングルは、IOTAトランザクションを含むイミュータブルなデータ構造です。IOTAネットワーク内のすべてのノードは、タングルのコピーを台帳に保存し、台帳から読み取り、新しいトランザクションを添付し、トランザクション内容について合意に達します。**\n<!-- **The Tangle is the immutable data structure that contains IOTA transactions. All nodes in an IOTA network store a copy of the Tangle in their ledgers, read from it, attach new transactions to it, and reach a consensus on its contents.** -->\n\nタングルでは、各トランザクションは参照によって他の2つのトランザクションに添付されています。\n<!-- In the Tangle, each transaction is attached to two others by reference. -->\n\nトランザクション間の参照は、[有向非巡回グラフ](https://en.wikipedia.org/wiki/Directed_acyclic_graph)（DAG）の型を形成します。これは、すべての辺がシーケンス内の前の点から後の点へ向かう頂点のシーケンスです。\n<!-- The references among transactions form a type of [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph) (DAG), which is a sequence of vertices where every edge is directed from an earlier point to a later one in the sequence. -->\n\nタングルでは、頂点はトランザクションであり、辺は参照です。\n<!-- In the Tangle, vertices are transactions, and edges are references. -->\n\n下図では、番号付きのボックスはトランザクションを表します。左側のトランザクションがシーケンスの先頭になり、右側のトランザクションが後になります。\n<!-- In this diagram, the numbered boxes represent transactions. The transactions on the left come first in the sequence, and the transactions on the right come after. -->\n\n![A directed acyclic graph](/assets/docs/dev-essentials/0.1/images/dag.png)\n\n## 親トランザクションと子トランザクション\n<!-- ## Parents and children -->\n\nノードが新しいトランザクションをタングルに添付すると、そのトランザクションは上図の左側にある2つの既存のトランザクションを直接参照します。\n<!-- When a node attaches a new transaction to the Tangle, that transaction directly references two existing ones to the left of it. -->\n\n参照は家系図を形成し、新しいトランザクションが**子トランザクション**の場合、ブランチおよびトランクトランザクションは**親トランザクション**になります。\n<!-- References form a family tree, whereby if a new transaction is a **child**, the branch and trunk transactions are its **parents**. -->\n\n上図では、トランザクション6はトランザクション5を直接参照しているため、トランザクション5はトランザクション6の**親トランザクション**です。一方、トランザクション6はトランザクション3を間接的に参照しているため、トランザクション3はトランザクション6の**祖父母トランザクション**です。\n<!-- In the diagram, transaction 6 directly references transaction 5, so transaction 5 is a **parent** of transaction 6. On the other hand, transaction 6 indirectly references transaction 3, so transaction 3 is a **grandparent** of transaction 6. -->\n\nこれらの直接および間接的な参照はトランザクションの履歴を構成します。\n<!-- These direct and indirect references make up a transaction's history. -->\n\nトランザクションが有効になるのは、履歴が自分のトランザクション内容と競合しない他の2つのトランザクションを参照している場合だけです。\n<!-- A transaction can be valid only if it references two other transaction's whose history does not conflict with it. -->\n\nたとえば、トランザクション6があるアドレスから10Miを取り出すようにノードに指示した場合、トランザクション6の親トランザクションの履歴がトランザクション6のアドレスに少なくとも10Miが送られているポイントに繋がっている必要があります。\n<!-- For example, if transaction 6 instructs the node to withdraw 10 Mi from an address, the history of its parents must lead to a point where that address is sent at least 10 Mi. -->\n\n## コンセンサス\n<!-- ## Consensus -->\n\nノードは、トランザクションとその履歴を検証して、競合しないことを確認する責任があります。トランザクションを検証するには、ノードはそのトランザクションの履歴を台帳に保持する必要があります。すべてのノードの台帳にあるトランザクションは**タングルの概観**を構成します。\n<!-- Nodes are responsible for validating transactions and their histories to make sure that they don't conflict. To validate a transaction, a node needs to have that transaction's history in its ledger. The transactions in any node's ledger make up its **view of the Tangle**. -->\n\nタングルはIOTAネットワーク内のすべてのノードに分散されているため、すべてのノードのうちのいくつかのノードはタングルのさまざまな概観を持つことができます。そのため、すべてのノードがタングルについて同じ概観を常に持っていることを確認するために、受信したすべての新しいトランザクションを隣接ノードに転送します。あるノードがトランザクションの履歴の一部を失っている場合、そのノードは隣接ノードに欠けているトランザクションを問い合わせます。\n<!-- Because the Tangle is distributed among all nodes in an IOTA network, some of them can have different views of the Tangle. So, to make sure that all nodes eventually have the same view of the Tangle, they forward any new transactions that they receive to their neighbors. If a node is missing part of a transaction's history, it will asks its neighbors for the missing transactions. -->\n\nノードにトランザクションの履歴がある場合、そのトランザクションは凝固していると見なされます。すべてのノードの目標は、台帳のトランザクションを凝固にすることです。\n<!-- When a node has a transaction's history, the transaction is considered solid. The goal of all nodes is to make the transactions in their ledgers solid. -->\n\n:::info:\nノードはトランザクションの全履歴を必要としません。トランザクションの履歴は、トランザクションを凝固と考えるための最初のトランザクションから始まります。\n\n代わりに、ノードには、エントリポイントと呼ばれる事前定義されたポイントまでのトランザクションの履歴が必要です。トランザクションの履歴がエントリポイントを参照するまでさかのぼると、ノードはトランザクションを凝固するのをやめます。\n\n定義済みエントリポイントの例は、[ローカルスナップショット](/docs/node-software/0.1/iri/concepts/local-snapshot)です。\n:::\n<!-- :::info: -->\n<!-- Nodes don't need the entire history of a transaction, starting from the first ever transaction to consider it solid. -->\n<!--  -->\n<!-- Instead, nodes need the history of a transaction up to a predefined one, which is called an entry point. When the transaction's history goes far back enough to reference an entry point, the node stops solidifying it. -->\n<!--  -->\n<!-- An example of a predefined entry point is a [local snapshot](/docs/node-software/0.1/iri/concepts/local-snapshot). -->\n<!-- ::: -->\n\nトランザクションが確定済みと見なされるためには、ノードは、アドレスの残高を更新する前に、いつ最終的なものと見なすべきかについて合意に達する必要があります。\n<!-- For a transaction to be considered confirmed, nodes must reach a consensus on when to consider it final before they can update the balances of addresses. -->\n\nトランザクションがコーディネーターによって送信され署名されたトランザクションによって直接または間接的に参照された場合に、トランザクションは確定済みと見なされます。\n<!-- A transaction is considered confirmed when it's directly or indirectly referenced by a transaction that's sent and signed by the Coordinator. -->\n\n### コーディネーター\n<!-- ### The Coordinator -->\n\nコーディネーターは、同じアドレスから定期的にトランザクションのバンドルを作成、署名、および送信するアプリケーションです。これらの各バンドルには、ノードが合意に達するために使用するマイルストーンと呼ばれるトランザクションが含まれています。マイルストーンがタングル内のあるトランザクションを直接または間接的に参照した場合、ノードはそのトランザクションの状態とその履歴全体を確定済みとしてマークします。\n<!-- The Coordinator is an application that creates, signs, and sends bundles of transactions from the same address at regular intervals. Each of these bundles contains transactions called milestones that nodes use to reach a consensus. When milestones directly or indirectly reference a transaction in the Tangle, nodes mark the state of that transaction and its entire history as confirmed. -->\n\n:::info:コーディサイド\n現時点では、コーディネーターの削除を提案する[コーディサイド](https://coordicide.iota.org/)というプロジェクトに注目しています。これが起こるとき、ノードはマイルストーンなしで合意に達することができます。\n:::\n<!-- :::info:Coordicide -->\n<!-- At the moment, we are focused on a project called [Coordicide](https://coordicide.iota.org/), which is a proposal for the removal of the Coordinator. When this happens, nodes will be able to reach a consensus without milestones. -->\n<!-- ::: -->\n\n### マイルストーン\n<!-- ### Milestones -->\n\nコーディネーターは定期的にマイルストーンをノードに送信します。ノードは合意に達するためにこれらのマイルストーンを使用します。\n<!-- The Coordinator sends milestones to nodes at regular intervals. Nodes use these milestones to reach a consensus. -->\n\nどのトランザクションがマイルストーンであるかを判断するために、同じIOTAネットワーク内のすべてのノードはコーディネーターのアドレスを知っています。\n<!-- To determine which transactions are milestones, all nodes in the same IOTA network know the address of the Coordinator. -->\n\nノードがコーディネーターのアドレスから送信されたトランザクションを確認したら、次の手順を実行して検証します。\n<!-- When nodes see a transaction that's been sent from the Coordinator's address, they validate it by doing the following: -->\n\n* マイルストーンが二重支払いにつながらないことを確かめる。\n<!-- * Make sure that it doesn't lead to a double-spend -->\n* マイルストーンの署名を確認する。\n<!-- * Verify its signature -->\n\nIOTAはWinternitzワンタイム署名方式（W-OTS）を使用するため、秘密鍵は1つのバンドルにのみ署名する必要があります。コーディネーターが複数のバンドルに署名しつつ、かつそれらすべての署名が1つのアドレスに対して検証できるようにするために、コーディネーターのアドレスはコーディネーターのマークル木から導出されます。\n<!-- Because IOTA uses the Winternitz one-time signature scheme (W-OTS), a private key should sign only one bundle. To allow the Coordinator to sign multiple bundles whose signatures can still be verified against one address, that address is derived from the Coordinator's Merkle tree. -->\n\n### コーディネーターのマークル木\n<!-- ### The Coordinator's Merkle tree -->\n\nマークル木は、リーフでデータをハッシュ化することから始まり、マークルルート（コーディネーターのアドレス）で終わるデータ構造です。\n<!-- A Merkle tree is a data structure that starts by hashing data at the leaves and ends at the Merkle root (the Coordinator's address). -->\n\n![Example Merkle tree](/assets/docs/dev-essentials/0.1/images/merkle-tree-example.png)\n\nコーディネーターは、自身のマークル木の各リーフに対して1つの署名付きバンドルを署名して送信できます。\n<!-- The Coordinator can sign and send one signed bundle for each leaf in its Merkle tree. -->\n\nこの例では、4つのリーフがあり、それぞれがコーディネーターの公開鍵と秘密鍵のペアの1つを表します。これらの鍵ペアは事前に作成され、コーディネーターのアドレスを計算するために使用されます。マークル木内の鍵ペアの総数は、公式`2<sup>depth</sup>`の`depth`によって異なります。この例では、マークル木の`depth`は2です。\n<!-- In this example, we have four leaves, which each represent one of the Coordinator's public/private key pairs. These key pairs are created in advance and used to compute the the Coordinator's address. The total number of key pairs in a Merkle tree depends on its depth in this formula: 2<sup>depth</sup>. In this example, the Merkle tree's depth is 2. -->\n\n:::info:\nMainnetでは、コーディネーターのマークル木の`depth`は23です。したがって、コーディネーターは`8,388,608`の公開鍵と秘密鍵のペアを持ち、同じ数のマイルストーンを送信できます。\n:::\n<!-- :::info: -->\n<!-- On the Mainnet, the Coordinator's Merkle tree has a depth of 23. So, the Coordinator has 8,388,608 public/private key pairs and can send the same number of milestones. -->\n<!-- ::: -->\n\nコーディネーターのアドレスを計算するために、公開鍵はペアでハッシュ化されます。\n<!-- To compute the Coordinator's address, the public keys are hashed in pairs: -->\n\n* **ノード1：** Hash(Hash(リーフ1の公開鍵) Hash(リーフ2の公開鍵))\n<!-- * **Node 1:** Hash(Hash(public key of leaf 1) Hash(public key of leaf 2)) -->\n* **ノード2：** Hash(Hash(リーフ3の公開鍵) Hash(リーフ4の公開鍵))\n<!-- * **Node 2:** Hash(Hash(public key of leaf 3) Hash(public key of leaf 4)) -->\n* **コーディネーターのアドレス：** Hash(Hash(ノード1) Hash(ノード2))\n<!-- * **Coordinator's address:** Hash(Hash(node 1) Hash(node 2)) -->\n\nノード1は、リーフ1の公開鍵とリーフ2の公開鍵の両方をハッシュ化した結果のハッシュ値です。ノード2は、リーフ3の公開鍵とリーフ4の公開鍵の両方をハッシュ化した結果のハッシュ値です。コーディネーターのアドレスは、ノード1とノード2のハッシュ値をハッシュ化した結果のハッシュ値です。\n<!-- Node 1 is a hash of the result of hashing both the public key of leaf 1 and the public key of leaf 2. Node 2 is a hash of the result of hashing both the public key of leaf 3 and the public key of leaf 4. The Coordinator's address is a hash of the result of hashing the hash of node 1 and node 2. -->\n\n:::info:\nコーディネーターの秘密鍵は、シード、インデックス、およびセキュリティレベルから導出します。\n\nMainnetでは、コーディネーターの秘密鍵はセキュリティレベル2です。結果として、マイルストーンの署名は1つのトランザクションに収まるには大きすぎるため、2つに分割する必要があります。\n\n[秘密鍵の導出方法の詳細を学ぶ](/docs/dev-essentials/0.1/concepts/addresses-and-signatures)。\n:::\n<!-- :::info: -->\n<!-- The Coordinator's private keys are derived from a seed, an index, and a security level. -->\n<!--  -->\n<!-- On the Mainnet, these private keys are security level 2. As a result, the milestone signature is too large to fit in one transaction and must be fragmented across two. -->\n<!--  -->\n<!-- [Learn more about how private keys are derived](/docs/dev-essentials/0.1/concepts/addresses-and-signatures). -->\n<!-- ::: -->\n\n### ノードがマイルストーンを検証する方法\n<!-- ### How nodes verify milestones -->\n\nマイルストーンを検証するには、ノードはマークル木を再構築してマークルルートを見つける必要があります。再構築されたマークルルートがコーディネーターのアドレスと同じ場合、ノードはマイルストーンがコーディネーターによって送信されたことを認識します。\n<!-- To verify milestones, nodes must rebuild the Merkle tree to find the Merkle root. If the rebuilt Merkle root is the same as the Coordinator's address, nodes know the milestone was sent by the Coordinator. -->\n\nノードがマークル木を再構築できるようにするために、コーディネーターはバンドル内に次のマイルストーンを送信します。\n<!-- To allow nodes to rebuild the Merkle tree, the Coordinator sends the following milestones in the bundle: -->\n\n* 断片化された署名を含む2つのトランザクション\n<!-- * Two transactions that contain the fragmented signature -->\n* [`signatureMessageFragment`](/docs/dev-essentials/0.1/references/structure-of-a-transaction)フィールドにマークル木を再構築することができるのに十分なマークル木からの足りないデータを含む1つのトランザクション。\n<!-- * One transaction whose [`signatureMessageFragment`](/docs/dev-essentials/0.1/references/structure-of-a-transaction) field contains enough missing data from the Merkle tree to be able to rebuild it -->\n\n![Example Merkle tree](/assets/docs/dev-essentials/0.1/images/merkle-tree-example.png)\n\nたとえば、ノードとして、リーフ1の秘密鍵で署名されたバンドルを見たとします。\n<!-- For example, as a node, we have seen a bundle that was signed with the private key of leaf 1. -->\n\nまず、署名を検証してリーフ1の公開鍵を見つけます。\n<!-- First, we verify the signature to find out the public key of leaf 1. -->\n\n:::info:\n[ノードが署名を検証する方法を学ぶ](/docs/dev-essentials/0.1/concepts/addresses-and-signatures#how-nodes-verify-signatures)。\n:::\n<!-- :::info: -->\n<!-- [Learn how nodes verify signatures](/docs/dev-essentials/0.1/concepts/addresses-and-signatures#how-nodes-verify-signatures) -->\n<!-- ::: -->\n\nマークルルートを計算するために、バンドルの3番目のマイルストーンには次のものが含まれます。\n<!-- To help us calculate the Merkle root, the third milestone in the bundle contains the following: -->\n\n* リーフ2の公開鍵\n<!-- * The public key of leaf 2 -->\n* ノード2のハッシュ値\n<!-- * The hash of node 2 -->\n\nここで、リーフ1とリーフ2の公開鍵をハッシュ化してノード1のハッシュ値を見つけます。次に、ノード1とノード2のハッシュ値をハッシュ化してマークルルートを見つけます。\n<!-- Now, we hash the public keys of leaves 1 and 2 to find the hash of node 1. Then we hash the hash of nodes 1 and 2 to find the Merkle root. -->\n\nマークルルートがコーディネーターのアドレスと同じ場合、バンドルはコーディネーターのマークル木の秘密鍵の1つで署名されています。\n<!-- If the Merkle root is the same as the Coordinator's address, the bundle was signed with one of the private keys in the Coordinator's Merkle tree. -->\n\n:::info:独自のコーディネーターを実行したいですか？\nコンパスを使用して、独自のプライベートタングルでマイルストーンを作成、署名、および送信します。\n:::\n<!-- :::info:Want to run your own Coordinator? -->\n<!-- Use Compass to create, sign, and send milestones in your own private Tangle. -->\n<!-- ::: -->\n\n## 参考文献\n<!-- ## Further research -->\n\nIOTA財団はタングルとそれに関連するプロトコルの開発に焦点を当てている活発な研究部を持っています。\n<!-- We have an active research department that focuses on developing the Tangle and its related protocols. -->\n\n* [学術論文](https://www.iota.org/research/academic-papers)\n<!-- * [Academic Papers](https://www.iota.org/research/academic-papers) -->\n* [ロードマップ](https://www.iota.org/research/roadmap)\n<!-- * [Roadmap](https://www.iota.org/research/roadmap) -->\n","title":"タングル | 概念 | 重要事項"}}
